/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.test;

import gov.hhs.fhh.service.TestServiceLocator;
import gov.hhs.fhh.service.locator.FhhRegistry;

import java.io.File;
import java.io.IOException;
import java.sql.SQLException;
import java.sql.Statement;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheException;
import net.sf.ehcache.CacheManager;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.LineIterator;
import org.apache.log4j.Logger;
import org.hibernate.HibernateException;
import org.hibernate.Transaction;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.junit.After;
import org.junit.Before;

import com.fiveamsolutions.nci.commons.util.HibernateUtil;

/**
 * @author Scott Miller
 * 
 */
public class AbstractHibernateTestCase {

    private static final Logger LOG = Logger.getLogger(AbstractHibernateTestCase.class);

    private static String[] sqlFiles = { 
        "/db-install/mysql/ethnicity.sql", 
        "/db-install/mysql/race.sql",
        "/db-install/mysql/observations.sql", 
         "/db-upgrade/mysql/2010-june-snomed-upgrades.sql",
         "/db-upgrade/mysql/FHH-1559.sql",
         "/db-upgrade/mysql/FHH-1635.sql",
         "/db-upgrade/mysql/FHH-1247.sql",
         "/db-upgrade/mysql/FHH-1659.sql",
         "/db-upgrade/mysql/FHH-1669.sql"
    };
    
    protected Transaction transaction;

    /**
     * In JUnit3x you would normally override the setUp() and add your own functionality locally however, in JUnit4 to
     * override simply define your method and give it the <code>@Before annotation</code>. Doing so will cause that
     * method to be invoked after the parent class's setUp().
     */
    @Before
    public final void setUp() {
        transaction = HibernateUtil.getHibernateHelper().beginTransaction();
        FhhRegistry.getInstance().setServiceLocator(new TestServiceLocator());
    }

    /**
     * In JUnit3x you would normally override the tearDown() and add your own functionality locally however, in JUnit4
     * to override simply define your method and give it the <code>@After annotation</code>. Doing so will cause that
     * method to be invoked after the parent class's tearDown().
     */
    @After
    public final void tearDown() {
        try {
            transaction.commit();
        } catch (Exception e) {
            HibernateUtil.getHibernateHelper().rollbackTransaction(transaction);
        }
    }

    @Before
    @SuppressWarnings("unchecked")
    public void initDbIfNeeded() throws HibernateException, SQLException, IOException {
        Transaction tx = HibernateUtil.getHibernateHelper().beginTransaction();
        LOG.debug("dropping and recreating db");
        SchemaExport se = new SchemaExport(HibernateUtil.getHibernateHelper().getConfiguration());
        se.drop(false, true);
        se.create(false, true);
        tx.commit();
        
        tx = HibernateUtil.getHibernateHelper().beginTransaction();
        Statement s = HibernateUtil.getCurrentSession().connection().createStatement();
        File sqlFile;
        s.execute("SET REFERENTIAL_INTEGRITY FALSE;");
        for (String filename : sqlFiles) {

            LOG.debug("Processing SQL for : " + filename);
            sqlFile = new File(TestProperties.getServicesBaseDir() + "/src/main/db" + filename);
            LineIterator lineIterator = FileUtils.lineIterator(sqlFile);
            while (lineIterator.hasNext()) {
                String sqlCmd = lineIterator.nextLine();
                String hsqldbSqlCmd = sqlCmd.replaceAll("\\\\'", "''").replaceAll("LAST_INSERT_ID", "IDENTITY");

                LOG.debug(hsqldbSqlCmd);
                try {
                    s.execute(hsqldbSqlCmd);
                } catch (SQLException e) {
                    LOG.error("failed to execute '" + filename + "'", e);
                    throw e;
                }
            }
        }
        s.execute("SET REFERENTIAL_INTEGRITY TRUE;");
        tx.commit();

    }

    @Before
    public void clearCaches() throws IllegalStateException, CacheException, IOException {
        for (String cacheName : CacheManager.getInstance().getCacheNames()) {
            Cache cache = CacheManager.getInstance().getCache(cacheName);
            cache.removeAll();
        }
    }

    /**
     * @return the hibernate transaction
     */
    public Transaction getTransaction() {
        return transaction;
    }
}
