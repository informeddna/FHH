/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data;

import static org.junit.Assert.assertEquals;
import gov.hhs.fhh.test.AbstractHibernateTestCase;
import gov.hhs.fhh.test.util.RelativeRelatedTestUtil;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import org.apache.commons.collections.set.ListOrderedSet;
import org.junit.Before;
import org.junit.Test;

import com.fiveamsolutions.hl7.model.mfhp.Gender;

/**
 * @author lpower
 *
 */
public class RelativeBranchTest extends AbstractHibernateTestCase {
    private final String DUMMY_NAME = "Proband";
    private final UUID DUMMY_ID = UUID.randomUUID();
    private final Gender DUMMY_GENDER = Gender.MALE;
    private final Person p = new Person();
    private final Date date = new Date();
    private Set<Relative> family = new ListOrderedSet();
    private RelativeBranch r;
    
    
    @Before
    public void before() {
        p.setName(DUMMY_NAME);
        p.setDateOfBirth(date);
        p.setUuid(DUMMY_ID);
    }
    
    @Test
    public void testSiblings() {
        List<Relative> relatives = RelativeRelatedTestUtil.createSiblings();
        p.setRelatives(relatives);
        family.addAll(relatives);
        r = new RelativeBranch(p);
        assertEquals(r.getSiblings(), family);
    }

    @Test
    public void testSiblingsWithKids() {
        List<Relative> relatives = RelativeRelatedTestUtil.createSiblingsAndKids();
        p.setRelatives(relatives);
        r = new RelativeBranch(p);
        family.addAll(relatives);
        assertEquals(r.getSiblings(), family);
    }


    @Test
    public void testHalfSiblings() {
        List<Relative> relatives = RelativeRelatedTestUtil.createSiblingsAndHalfSiblings();
        p.setRelatives(relatives);
        family.addAll(relatives);
        r = new RelativeBranch(p);
        assertEquals(r.getSiblings(), family);
    }

    @Test
    public void testHalfSiblingsWithKids() {
        List<Relative> relatives = RelativeRelatedTestUtil.createSiblingsAndHalfSiblingsAndKids();
        p.setRelatives(relatives);
        family.addAll(relatives);
        family.remove(p.getRelativeOfType(RelativeCode.NMTH));
        family.remove(p.getRelativeOfType(RelativeCode.NFTH));
        r = new RelativeBranch(p);
        assertEquals(r.getSiblings(), family);
    }

    @Test
    public void testPaternalAuntsUncles() {
        List<Relative> relatives = RelativeRelatedTestUtil.createAuntsUncles();
        relatives.addAll(RelativeRelatedTestUtil.createGrands());
        Relative gramps = new Relative(new Person(), RelativeCode.PGRFTH);
        Relative gram = new Relative(new Person(), RelativeCode.PGRMTH);
        relatives.add(gramps);
        relatives.add(gram);
        p.setRelatives(relatives);
        family.add(gramps);
        family.add(gram);
        family.addAll(getPaternalAuntsUnclesCousins(relatives));
        r = new RelativeBranch(p);
        assertEquals(r.getFatherBranch(), family);
    }

    @Test
    public void testPaternalCousins() {
        List<Relative> relatives = RelativeRelatedTestUtil.createAuntsUnclesCousins();
        Relative gramps = new Relative(new Person(), RelativeCode.PGRFTH);
        Relative gram = new Relative(new Person(), RelativeCode.PGRMTH);
        relatives.add(gramps);
        relatives.add(gram);
        p.setRelatives(relatives);
        // pull out paternal aunts and uncles to match
        family.add(gramps);
        family.add(gram);
        family.addAll(getPaternalAuntsUnclesCousins(relatives));
        r = new RelativeBranch(p);
        assertEquals(r.getFatherBranch(), family);

    }

    @Test
    public void testMaternalAuntsUncles() {
        List<Relative> relatives = RelativeRelatedTestUtil.createAuntsUncles();
        Relative gramps = new Relative(new Person(), RelativeCode.MGRFTH);
        Relative gram = new Relative(new Person(), RelativeCode.MGRMTH);
        relatives.add(gramps);
        relatives.add(gram);
        p.setRelatives(relatives);
        family.add(gramps);
        family.add(gram);
        family.addAll(getMaternalAuntsUnclesCousins(relatives));
        r = new RelativeBranch(p);
        assertEquals(r.getMotherBranch(), family);
    }

    @Test
    public void testMaternalCousins() {
        List<Relative> relatives = RelativeRelatedTestUtil.createAuntsUnclesCousins();
        Relative gramps = new Relative(new Person(), RelativeCode.MGRFTH);
        Relative gram = new Relative(new Person(), RelativeCode.MGRMTH);
        relatives.add(gramps);
        relatives.add(gram);
        p.setRelatives(relatives);
        family.add(gramps);
        family.add(gram);
        // pull out only the maternal relatives
        family.addAll(getMaternalAuntsUnclesCousins(relatives));
        r = new RelativeBranch(p);
        assertEquals(r.getMotherBranch(), family);
    }

    @Test
    public void testPaternalGrandparents() {
        List<Relative> relatives = RelativeRelatedTestUtil.createGrands();
        p.setRelatives(relatives);
        family.addAll(getPaternalGrands(relatives));
        r = new RelativeBranch(p);
        assertEquals(r.getFatherBranch(), family);
    }

    @Test
    public void testMaternalGrandparents() {
        List<Relative> relatives = RelativeRelatedTestUtil.createGrands();
        p.setRelatives(relatives);
        family.addAll(getMaternalGrands(relatives));
        r = new RelativeBranch(p);
        assertEquals(r.getMotherBranch(), family);
    }

    

    
    /**
     * @param relatives
     * @return
     */
    private List<Relative> getSibs(List<Relative> relatives) {
        List<Relative> mysibs = new ArrayList<Relative>();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.NBRO.toString() 
                    || myrel.getCode().toString() == RelativeCode.NSIS.toString()) {
                mysibs.add(myrel);
            }
        }
        return mysibs;
    }

    /**
     * @param relatives
     * @return
     */
    private Set<Relative> getSibsKids(Set<Relative> relatives) {
        Set<Relative> mySibsKids = new ListOrderedSet();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.NBRO.toString() 
                    || myrel.getCode().toString() == RelativeCode.NSIS.toString()) {
                mySibsKids.addAll(myrel.getDescendants());
            }
        }
        return mySibsKids;
    }
    
    /**
     * @param relatives
     * @return
     */
    private List<Relative> getPaternalAuntsUnclesCousins(List<Relative> relatives) {
        List<Relative> ret = new ArrayList<Relative>();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.PAUNT.toString() 
                    || myrel.getCode().toString() == RelativeCode.PUNCLE.toString() 
                    ||  myrel.getCode().toString() == RelativeCode.PCOUSN.toString()) {
                ret.add(myrel);
            }
        }
        return ret;
    }

    /**
     * @param relatives
     * @return
     */
    private List<Relative> getMaternalAuntsUnclesCousins(List<Relative> relatives) {
        List<Relative> ret = new ArrayList<Relative>();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.MAUNT.toString() 
                    || myrel.getCode().toString() == RelativeCode.MUNCLE.toString() 
                    || myrel.getCode().toString() == RelativeCode.MCOUSN.toString()) {
                ret.add(myrel);
            }
        }
        return ret;
    }

    /**
     * @param relatives
     * @return
     */
    private Set<Relative> getPaternalCousins(Set<Relative> relatives) {
        Set<Relative> cousins = new ListOrderedSet();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.PCOUSN.toString()) {
                cousins.add(myrel);
            }
        }
        return cousins;
    }

    /**
     * @param relatives
     * @return
     */
    private Set<Relative> getMaternalCousins(Set<Relative> relatives) {
        Set<Relative> cousins = new ListOrderedSet();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.MCOUSN.toString()) {
                cousins.add(myrel);
            }
        }
        return cousins;
    }
    
    /**
     * @param relatives
     * @return
     */
    private List<Relative> getPaternalGrands(List<Relative> relatives) {
        List<Relative> ret = new ArrayList<Relative>();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.PGRFTH.toString() 
                    || myrel.getCode().toString() == RelativeCode.PGRMTH.toString()) {
                ret.add(myrel);
            }
        }
        return ret;
    }

    /**
     * @param relatives
     * @return
     */
    private List<Relative> getMaternalGrands(List<Relative> relatives) {
        List<Relative> ret = new ArrayList<Relative>();
        for (Relative myrel : relatives) {
            if (myrel.getCode().toString() == RelativeCode.MGRFTH.toString() 
                    || myrel.getCode().toString() == RelativeCode.MGRMTH.toString()) {
                ret.add(myrel);
            }
        }
        return ret;
    }

    /**
     * @param relatives list of this person's relatives
     * @param relative this relative whose children we're looking for
     */
    private void fillRelativeChildren(List<Relative> relatives, Relative potentialParent) {
        for (Relative myrel : relatives) {
            Relative parent = new Relative();
            if (myrel.getFather() != null) {
                parent = myrel.getFather();
            }
            if (myrel.getMother() != null) {
                parent = myrel.getMother();
            }
            if (parent != null && parent.equals(potentialParent)) {
                potentialParent.getDescendants().add(myrel);
            }
        }
    }
    
}
