/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data;

import gov.hhs.fhh.data.util.PersonUtils;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import org.apache.commons.collections.set.ListOrderedSet;
import org.hibernate.validator.Length;

import com.fiveamsolutions.hl7.model.mfhp.Gender;
import com.fiveamsolutions.hl7.model.mfhp.Height;
import com.fiveamsolutions.hl7.model.mfhp.TwinStatus;
import com.fiveamsolutions.hl7.model.mfhp.Weight;

/**
 * @author Scott Miller
 */
@SuppressWarnings({ "PMD.TooManyFields", "PMD.ExcessiveClassLength" })
public class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final int NAME_LENGTH = 255;
    
    /**
     * String representing true used by Castor.
     */
    protected static final String TRUE_STRING = "true";

    private UUID uuid;
    private String name;
    private Date dateOfBirth;
    private Weight weight = new Weight();
    private Height height = new Height();
    private Gender gender;
    private List<Ethnicity> ethnicities = new ArrayList<Ethnicity>();
    private List<Race> races = new ArrayList<Race>();
    private boolean adopted = false;
    private List<ClinicalObservation> observations = new ArrayList<ClinicalObservation>();
    private List<Relative> relatives = new ArrayList<Relative>();
    // Form was filled out for relative. We set the originalText for gender if the form was not filled out in order
    // to set completedForm to false on import.
    private boolean unmatchedCondition = false;
    private List<Relative> htmImportDroppedRelatives = new ArrayList<Relative>();
    
    // this list will contain the unrelated relatives, possibly including the relatives in htmImportDroppedRelatives.
    private final List<Relative> unrelatedRelatives = new ArrayList<Relative>();

    // Links to Mother and Father Relatives
    // Set for only Proband, cousins, grandchildren, half-Siblings, nieces, nephews
    private Relative father;
    private Relative mother;

    private boolean consanguinityFlag = false;
    private TwinStatus twinStatus = TwinStatus.NO;

    private Set<Relative> descendants = new ListOrderedSet();
    
    private boolean xmlFileSaved;

    /**
     * Default constructor.
     */
    public Person() {
        super();
        generateUuid();
    }

    /**
     * Copy constructor.
     * 
     * @param p the Person object to copy from.
     */
    public Person(final Person p) {
        super();
        uuid = p.getUuid();
        name = p.getName();
        dateOfBirth = p.getDateOfBirth();
        weight = new Weight(p.getWeight().getValue(), p.getWeight().getUnit());
        height = p.getHeight();
        gender = p.getGender();
        ethnicities = p.getEthnicities();
        races = p.getRaces();
        observations.addAll(p.getObservations());
        adopted = p.isAdopted();
        relatives.addAll(p.getRelatives());
        twinStatus = p.getTwinStatus();
        unmatchedCondition = p.isUnmatchedCondition();
        unrelatedRelatives.addAll(p.getUnrelatedRelatives());
    }

    /**
     * Returns boolean indicating if person is twin.
     * 
     * @return true if person is twin, otherwise false
     */
    public boolean isTwin() {
        boolean isTwin = false;
        if (twinStatus != null && !twinStatus.equals(TwinStatus.NO)) {
            isTwin = true;
        }
        return isTwin;
    }

    /**
     * Get unit for height and weight - need inches and lbs OR meters and kg
     *   formula for inches and lbs.
     *   BMI = (weight in lbs * 703)/(height in inches)(height in inches).
     *   BMI = (weight in kg)/(height in meters).
     * @return the bmi
     */
    public String getBmi() {
        return PersonUtils.calculateBmi(this);
    }

    /**
     * @param relCode type of relatives to return
     * @return list of relatives of given type.
     */
    public List<Relative> getRelativesOfType(final RelativeCode relCode) {
        return getRelativesOfType(relCode, getRelatives());
    }

    /**
     * @param relCode type of relative to return
     * @return the relative of given type, or null if no relatives of that type were found.
     */
    public Relative getRelativeOfType(final RelativeCode relCode) {
        return getRelativeOfType(relCode, getRelatives());
    }

    
    /**
     * @param relCode type of relatives to return
     * @return list of relatives of given type.
     */
    public List<Relative> getUnrelatedRelativesOfType(final RelativeCode relCode) {
        return getRelativesOfType(relCode, getUnrelatedRelatives());
    }

    /**
     * @param relCode type of relative to return
     * @return the relative of given type, or null if no relatives of that type were found.
     */
    public Relative getUnrelatedRelativeOfType(final RelativeCode relCode) {
        return getRelativeOfType(relCode, getUnrelatedRelatives());
    }
    
    private Relative getRelativeOfType(RelativeCode relCode, List<Relative> relativeListToSearch) {
        final List<Relative> rels = getRelativesOfType(relCode, relativeListToSearch);
        if (rels.isEmpty()) {
            return null;
        }
        if (rels.size() == 1) {
            return rels.get(0);
        }
        throw new IllegalArgumentException("More than one relative of type " + relCode);
    }

    private List<Relative> getRelativesOfType(final RelativeCode relCode, List<Relative> relativeListToSearch) {
        final List<Relative> rels = new ArrayList<Relative>();
        for (final Relative rel : relativeListToSearch) {
            if (rel.getCodeEnum() == relCode) {
                rels.add(rel);
            }
        }
        return rels;
    }
    
    /**
     * @param relName name of relative to return
     * @return the first relative with given name, or null if no relatives with that name found
     */
    public Relative getRelativeByName(final String relName) {
        for (final Relative rel : relatives) {
            if (rel.getName().equals(relName)) {
                return rel;
            }
        }
        return null;
    }
    

    /**
     * recenters the family history on the relative with given index.
     * 
     * @param id uuid of relative on whom to recenter.
     * @return the person on whom the history has been recentered, with a properly populated list of relatives.
     */
    public Person recenterOn(final UUID id) {
        final RelationshipGraph relGraph = new RelationshipGraph(this);
        final Relative centerRelative = getRelative(id);
        return relGraph.centerOn(centerRelative);
    }

    /**
     * @return the list of race IDs
     */
    public List<Long> getRaceIds() {
        final List<Long> raceIds = new ArrayList<Long>();
        for (final Race currRace : races) {
            raceIds.add(currRace.getId());
        }
        return raceIds;
    }

    /**
     * @return the list of race IDs
     */
    public List<Long> getEthnicityIds() {
        final List<Long> raceIds = new ArrayList<Long>();
        for (final Ethnicity currEthnicity : ethnicities) {
            raceIds.add(currEthnicity.getId());
        }
        return raceIds;
    }
    
    /**
     * @return calculated age of this person
     */
    public int getMyAge() {
        int age = 0;
        if (getDateOfBirth() != null) {
            final GregorianCalendar currCal = new GregorianCalendar();
            final GregorianCalendar birthCal = new GregorianCalendar();
            birthCal.setTime(getDateOfBirth());
            age = currCal.get(Calendar.YEAR) - birthCal.get(Calendar.YEAR);
            if (birthCal.get(Calendar.MONTH) > currCal.get(Calendar.MONTH) 
                    || birthCal.get(Calendar.MONTH) == birthCal.get(Calendar.MONTH)
                            && birthCal.get(Calendar.DAY_OF_MONTH) > currCal.get(Calendar.DAY_OF_MONTH)) {
                age--;
            }
        }
        return age;
    }

    /**
     * Used in familyHistoryDetail.jsp to find if the Proband or any of the relatives contained unmatched conditions
     *  after a legacy import (A user entered disease that did not match up with any FHH diseases).
     * @return boolean true if unmatched condition exists, otherwise false
     */
    public boolean isFamilyContainsUnmatchedCondition() {
        boolean unmatched = false;
        if (isUnmatchedCondition()) {
            unmatched = true;
        }
        for (final Relative currRelative : getRelatives()) {
            if (currRelative.isUnmatchedCondition()) {
                unmatched = true;
            }
        }
        return unmatched;
    }
    
    /**
     * Returns if the form has been completed for the Proband.  DOB is a required field, if it has been stored,
     * form has been completed.
     * @return boolean indicating that form has been completed
     */
    public boolean isCompletedForm() {
        return dateOfBirth != null;
    }
    
    /**
     * @return the gender
     */
    public Gender getGender() {
        return gender;
    }
    
    /**
     * @param gender the gender to set
     */
    public void setGender(final Gender gender) {
        this.gender = gender;
    }

    /**
     * @return the name
     */
    @Length(max = NAME_LENGTH)
    public String getName() {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(final String name) {
        this.name = name;
    }

    /**
     * @return the dateOfBirth
     */
    public Date getDateOfBirth() {
        return dateOfBirth;
    }

    /**
     * @param dateOfBirth the dateOfBirth to set
     */
    public void setDateOfBirth(final Date dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
    }

    /**
     * @return the adopted
     */
    public boolean isAdopted() {
        return adopted;
    }

    /**
     * @param adopted the adopted to set
     */
    public void setAdopted(final boolean adopted) {
        this.adopted = adopted;
    }
    
    /**
     * @return the observations
     */
    public List<ClinicalObservation> getObservations() {
        return observations;
    }

    /**
     * @param observations the observations to set
     */
    public void setObservations(final List<ClinicalObservation> observations) {
        this.observations = observations;
    }

    /**
     * @return the relatives
     */
    public List<Relative> getRelatives() {
        return relatives;
    }

    /**
     * @param relatives the relatives to set
     */
    public void setRelatives(final List<Relative> relatives) {
        this.relatives = relatives;
    }

    /**
     * @return the father
     */
    public Relative getFather() {
        return father;
    }

    /**
     * @param father the father to set
     */
    public void setFather(final Relative father) {
        this.father = father;
    }

    /**
     * @return the mother
     */
    public Relative getMother() {
        return mother;
    }

    /**
     * @param mother the mother to set
     */
    public void setMother(final Relative mother) {
        this.mother = mother;
    }

    /**
     * @return the descendants
     */
    public Set<Relative> getDescendants() {
        return descendants;
    }

    /**
     * @param descendants the descendants to set
     */
    public void setDescendants(final Set<Relative> descendants) {
        this.descendants = descendants;
    }
    
    /**
     * @return the races
     */
    public List<Race> getRaces() {
        return races;
    }

    /**
     * @param races the races to set
     */
    public void setRaces(final List<Race> races) {
        this.races = races;
    }
    
    /**
     * @return the ethnicities
     */
    public List<Ethnicity> getEthnicities() {
        return ethnicities;
    }

    /**
     * @param ethnicities the ethnicities to set
     */
    public void setEthnicities(final List<Ethnicity> ethnicities) {
        this.ethnicities = ethnicities;
    }
    
    /**
     * @return the consanguinityFlag
     */
    public boolean isConsanguinityFlag() {
        return consanguinityFlag;
    }

    /**
     * @param consanguinityFlag the consanguinityFlag to set
     */
    public void setConsanguinityFlag(final boolean consanguinityFlag) {
        this.consanguinityFlag = consanguinityFlag;
    }

    /**
     * @return the twinStatus
     */
    public TwinStatus getTwinStatus() {
        return twinStatus;
    }

    /**
     * @param twinStatus the twinStatus to set
     */
    public void setTwinStatus(final TwinStatus twinStatus) {
        this.twinStatus = twinStatus;
    }

    /**
     * @return the height
     */
    public Height getHeight() {
        return height;
    }

    /**
     * @param height the height to set
     */
    public void setHeight(final Height height) {
        this.height = height;
    }

    /**
     * @return the unmatchedCondition
     */
    public boolean isUnmatchedCondition() {
        return unmatchedCondition;
    }

    /**
     * @param unmatchedCondition the unmatchedCondition to set
     */
    public void setUnmatchedCondition(final boolean unmatchedCondition) {
        this.unmatchedCondition = unmatchedCondition;
    }

    /**
     * @return the htmImportDroppedRelatives
     */
    public List<Relative> getHtmImportDroppedRelatives() {
        return htmImportDroppedRelatives;
    }

    /**
     * @param htmImportDroppedRelatives the htmImportDroppedRelatives to set
     */
    public void setHtmImportDroppedRelatives(final List<Relative> htmImportDroppedRelatives) {
        this.htmImportDroppedRelatives = htmImportDroppedRelatives;
    }

    /**
     * @return the weight
     */
    public Weight getWeight() {
        return weight;
    }

    /**
     * @param weight the weight to set
     */
    public void setWeight(final Weight weight) {
        this.weight = weight;
    }

    /**
     * @return the xmlFileSaved
     */
    public boolean isXmlFileSaved() {
        return xmlFileSaved;
    }

    /**
     * @param xmlFileSaved the xmlFileSaved to set
     */
    public void setXmlFileSaved(final boolean xmlFileSaved) {
        this.xmlFileSaved = xmlFileSaved;
    }

    /**
     * @param uuid the uuid to set
     */
    public void setUuid(final UUID uuid) {
        this.uuid = uuid;
    }

    /**
     * @return the uuid
     */
    public UUID getUuid() {
        return uuid;
    }
    
    /**
     * Method generates a new UUID.
     */
    public final void generateUuid() {
        uuid = UUID.randomUUID();
    }

    /**
     * @param id UUID of the Relative
     * @return relative if match is found in either related or unrelated relative lists, otherwise, null
     */
    public final Relative getRelative(final UUID id) {
        for (final Relative r : relatives) {
            if (id.equals(r.getUuid())) {
                return r;
            }
        }
        for (final Relative r : unrelatedRelatives) {
            if (id.equals(r.getUuid())) {
                return r;
            }
        }

        return null;
    }

    /**
     * @return the unrelatedRelatives - the relatives that are not parents or children of any of the related relatives.
     */
    public List<Relative> getUnrelatedRelatives() {
        return unrelatedRelatives;
    }
}
