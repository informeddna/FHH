/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services (“HHS”) hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the “software”) and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data.util.htmimport;

import gov.hhs.fhh.data.AgeRange;
import gov.hhs.fhh.data.ClinicalObservation;
import gov.hhs.fhh.data.Disease;
import gov.hhs.fhh.data.Gender;
import gov.hhs.fhh.data.Height;
import gov.hhs.fhh.data.HeightUnit;
import gov.hhs.fhh.data.LivingStatus;
import gov.hhs.fhh.data.Person;
import gov.hhs.fhh.data.Relative;
import gov.hhs.fhh.data.RelativeCode;
import gov.hhs.fhh.data.TwinStatus;
import gov.hhs.fhh.data.Weight;
import gov.hhs.fhh.data.WeightUnit;
import gov.hhs.fhh.data.util.DiseaseUtils;
import gov.hhs.fhh.data.util.FhhDataUtils;
import gov.hhs.fhh.data.util.FormatUtils;
import gov.hhs.fhh.data.util.PersonUtils;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang.StringUtils;

/**
 * @author bpickeral
 *
 */
@SuppressWarnings("PMD.TooManyMethods")
public final class HTMImportUtils {

    /**
     * The number of fixed relatives always in the legacy import. Includes parents + grandparents.
     */
    public static final int NUM_FIXED_RELATIVES = 7;
    
    /**
     * The value of the parent node for Relatives that don't need to specify parents.
     */
    public static final String CALCULATED = "calculated";
    
    private static final String YES = "Yes";
    private static final int NAME_INDEX = 0;
    private static final int LIVING_INDEX = 1;
    private static final int GENDER_INDEX = 2;
    private static final int ADD_DISEASES_INDEX = 3;
    private static final int PARENT_INDEX = 4;
    private static final int AGE_AT_DEATH_INDEX = 5;
    private static final int TWIN_INDEX = 6;
    private static final int COD_INDEX = 7;
    private static final int HEART_DISEASE_INDEX = 8;
    private static final int STROKE_INDEX = 10;
    private static final int DIABETES_INDEX = 12;
    private static final int COLON_CANCER_INDEX = 14;
    private static final int BREAST_CANCER_INDEX = 16;
    private static final int OVARIAN_CANCER_INDEX = 18;
    private static final int FAMILY_ADD_DISEASE_INDEX = 20;
    
    private static final String FEMALE = "female";
    private static final String MALE = "male";
    
    //private static final Logger LOG = Logger.getLogger(HTMImportUtils.class);
    
    
    /**
     * Separates a single list of <code>InputNode</code> objects into a list of <code>HTMNode</code>
     *  objects,  each containing a list of <code>InputNode</code> objects associated with a single relative.
     *  Only separates mother, father, and grandparent nodes.  The remaining input is stored in a single HTMNode
     *  to be processed later since it is in a different format.
     * @param node node containing <code>InputNode</code> objects
     * @return list of <code>HTMNode</code> objects
     */
    public static List<HTMNode> seperateFixedRelatives(HTMNode node) {
        RelativeCode lastRelativeCode = null;
        RelativeCode currRelativeCode;
        List<HTMNode> relativeNodes = new ArrayList<HTMNode>();
        HTMNode currHTMNode = null;
        int index = 0;
        // Set the first relative to self
        lastRelativeCode = RelativeCode.SELF;
        currHTMNode = new HTMNode(lastRelativeCode, null);
        relativeNodes.add(currHTMNode);
        // Separate fixed relatives into HTMNode objects
        for (InputNode currNode : node.getInputNodes()) {
            currRelativeCode = getRelativeCode(lastRelativeCode, currNode);
            // If the last relative code is different from the current one, start storing attributes in a new
            // HTMNode
            if (!lastRelativeCode.equals(currRelativeCode)) {
                if (relativeNodes.size() == NUM_FIXED_RELATIVES) {
                    break;
                }
                currHTMNode = new HTMNode(currRelativeCode, null);
                relativeNodes.add(currHTMNode);
            } 
            currHTMNode.getInputNodes().add(currNode);
            
            index++;
            lastRelativeCode = currRelativeCode;
        }
        // Store remaining InputNode objects in a single HTMNode object to be processed after
        // fixed relatives (parents, grandparents)
        currHTMNode = new HTMNode();
        currHTMNode.getInputNodes().addAll(node.getInputNodes().subList(index, node.getInputNodes().size()));
        relativeNodes.add(currHTMNode);
        return relativeNodes;
    }
    
    private static RelativeCode getRelativeCode(RelativeCode lastRelativeCode, InputNode inputNode) {
        RelativeCode relativeCode = null;
        if (inputNode.getName().startsWith(lastRelativeCode.getHtmValue())) {
            relativeCode = lastRelativeCode;
        } else {
            relativeCode = inputNode.getRelativeCode();
        }
        return relativeCode;
    }
    
    /**
     * Processes an <code>HTMNode</code> object associated with a Person and stores the
     *  information in the <code>Person</code> object.
     * @param p the <code>Person</code> object
     * @param node the <code>HTMNode</code> containing information about Self.
     * @param familyAddConditions the list of family conditions
     */
    public static void processPersonAttributes(Person p, HTMNode node, List<Disease> familyAddConditions) {
        List<InputNode> inputNodes = node.getInputNodes();

        //InputNode currInputNode;
        setHTMName(p, inputNodes.get(NAME_INDEX));
        // We always assume Self is living, ignore self living status
        setHTMGender(p, inputNodes.get(GENDER_INDEX));
        // TO Do: handle additional diseases
        setHTMTwinStatus(p, inputNodes.get(TWIN_INDEX));
        
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(HEART_DISEASE_INDEX), 
                DiseaseUtils.HEART_DISEASE_ID), inputNodes.get(HEART_DISEASE_INDEX + 1));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(STROKE_INDEX), 
                DiseaseUtils.STROKE_ID), inputNodes.get(STROKE_INDEX + 1));
        setAgeRangeForObservation(createDiabetesObservation(p, inputNodes.get(DIABETES_INDEX), 
                DiseaseUtils.DIABETES_ID), inputNodes.get(DIABETES_INDEX + 1));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(COLON_CANCER_INDEX), 
                DiseaseUtils.COLON_CANCER_ID), inputNodes.get(COLON_CANCER_INDEX + 1));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(BREAST_CANCER_INDEX), 
                DiseaseUtils.BREAST_CANCER_ID), inputNodes.get(BREAST_CANCER_INDEX + 1));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(OVARIAN_CANCER_INDEX), 
                DiseaseUtils.OVARIAN_CANCER_ID), inputNodes.get(OVARIAN_CANCER_INDEX + 1));
        // The legacy input handles additional diseases in 2 different places
        // Handle the additional diseases entered on each individual relative screen
        setHTMAdditionalDiseases(p, inputNodes.get(ADD_DISEASES_INDEX));
        // Handle the additional diseases that are tracked for the entire family tree 
        setHTMFamilyAdditionalDiseases(p, node, familyAddConditions);
        
        if (!p.isUnmatchedCondition()) {
            p.setCompletedForm(true);
        }
    }
    
    /**
     * Processes an <code>HTMNode</code> object associated with a relative and stores the
     *  information in the <code>Person</code> object.
     * @param p the <code>Person</code> object
     * @param node the <code>HTMNode</code> containing information about Self.
     * @param familyAddConditions the list of family conditions
     * @return relative Relative added to the tree
     */
    public static Relative processRelativeAttributes(Person p, HTMNode node, List<Disease> familyAddConditions) {
        List<InputNode> inputNodes = node.getInputNodes();
        Relative relative = createRelative(p, node);
        p.getRelatives().add(relative);
        
        processPersonAttributes(relative, node, familyAddConditions);
        
        setHTMLivingStatus(relative, inputNodes.get(LIVING_INDEX));
        setHtmAgeAtDeath(relative, inputNodes.get(AGE_AT_DEATH_INDEX));
        setHtmCauseOfDeath(relative, inputNodes.get(COD_INDEX));

        return relative;
    }
    
    /**
     * Creates the relative and sets the RelativeCode.
     */
    private static Relative createRelative(Person proband, HTMNode node) {
        Relative relative = new Relative();
        relative.setCode(node.getRelativeCode().toString());
        // Set proband's mother if node is mother node
        if (RelativeCode.NMTH.equals(node.getRelativeCode())) {  
            proband.setMother(relative);
        // Set proband's father if node is father node
        } else if (RelativeCode.NFTH.equals(node.getRelativeCode())) {
            proband.setFather(relative);
        }
        return relative;
    }
    
    private static void setHTMName(Person p, InputNode node) {
        if (!StringUtils.isEmpty(node.getValue())) {
            p.setName(node.getValue());
        }
    }
    
    private static void setHTMLivingStatus(Relative r, InputNode node) {
        if (!StringUtils.isEmpty(node.getValue())) {
            r.setLivingStatus(LivingStatus.fromHTMInputNode(node).toString());
        }
    }
    
    private static void setHtmAgeAtDeath(Relative r, InputNode node) {
        // Legacy system did not have error checking non int value was entered in user input
        if (!StringUtils.isBlank(node.getValue()) && StringUtils.isNumeric(node.getValue())) {
            r.setAgeAtDeath(AgeRange.fromHTMInputNode(node));
        } 
    }
    
    private static void setHtmCauseOfDeath(Relative r, InputNode node) {
        if (!StringUtils.isBlank(node.getValue())) {
            r.setCauseOfDeath(DiseaseUtils.findOrCreateNewDisease(node.getValue()));
        } 
    }
    
    
    
    private static void setHTMAdditionalDiseases(Person p, InputNode node) {
        if (!StringUtils.isBlank(node.getValue())) {
            String[] diseaseAgePairs = StringUtils.split(node.getValue(), ',');
            for (String currPair : diseaseAgePairs) {
                addObservationForAdditionalDisease(p, currPair);
            }
        }
    }
    
    private static void setHTMFamilyAdditionalDiseases(Person p, HTMNode htmNode, List<Disease> familyAddConditions) {
        List<InputNode> nodes = htmNode.getInputNodes();
        int j = 0;
        if (nodes.size() >= FAMILY_ADD_DISEASE_INDEX + 1) {
            for (int i = FAMILY_ADD_DISEASE_INDEX; i < nodes.size(); i = i + 2) {
                setAgeRangeForObservation(createHTMFamilyAdditionalObservation(p, nodes.get(i), 
                        familyAddConditions.get(j)), nodes.get(i + 1));
                j++;
            }
        }
    }
    
    private static ClinicalObservation createHTMFamilyAdditionalObservation(Person p, InputNode inputNode, 
            Disease condition) {
        ClinicalObservation obs = null;
        if (isBooleanInputTrue(inputNode)) {
            obs = new ClinicalObservation();
            obs.setDisease(condition);
            DiseaseUtils.setMatchedOrUnmatched(p, obs);
            p.getObservations().add(obs);
        }
        return obs;
    }
    
    private static void addObservationForAdditionalDisease(Person p, String diseaseAgePair) {
        ClinicalObservation obs = new ClinicalObservation();
        int separatorIndex = diseaseAgePair.lastIndexOf('/');
        String disease = null;
        AgeRange ageAtDiagnosis = null;
        // The legacy tool used separator characters ',' and '/', but allowed users to add additional characters of 
        // the same type and had no error checking. If there is ever a pair without a separator, extract the condition
        // and set age range to unknown.
        if (separatorIndex == -1) {
            disease = diseaseAgePair;
        } else {
            disease = StringUtils.substring(diseaseAgePair, 0, separatorIndex);
            ageAtDiagnosis = AgeRange.getByHtmValue(StringUtils.substring(diseaseAgePair, separatorIndex + 1));
        }
        if (ageAtDiagnosis == null) {
            ageAtDiagnosis = AgeRange.UNKNOWN;
        }
        
        obs.setDisease(DiseaseUtils.findOrCreateNewDisease(disease));
        obs.setAgeRange(ageAtDiagnosis);
        DiseaseUtils.setMatchedOrUnmatched(p, obs);
        p.getObservations().add(obs);
    }
    
    private static void setAgeRangeForObservation(ClinicalObservation observation, InputNode node) {
        if (observation != null) {
            if (StringUtils.isEmpty(node.getValue())) {
                observation.setAgeRange(AgeRange.UNKNOWN);
            } else {
                observation.setAgeRange(AgeRange.getByHtmValue(node.getValue()));
            }
        }
    }
    
    private static ClinicalObservation createClinicalObservation(Person p, InputNode node, long conditionId) {
        ClinicalObservation observation = null;
        if (isBooleanInputTrue(node)) {
            Disease d = FhhDataUtils.getIdToDiseaseMap().get(conditionId);
            observation = new ClinicalObservation();
            observation.setDisease(d);
            p.getObservations().add(observation);
        }
        return observation;
    }
    
    private static ClinicalObservation createDiabetesObservation(Person p, InputNode node, long conditionId) {
        ClinicalObservation obs = createClinicalObservation(p, node, conditionId);
        if (obs != null) {
            obs.setUnmatchedCondition(true);
            p.setUnmatchedCondition(true);
        }
        return obs;
    }
    
    private static void setHTMTwinStatus(Person p, InputNode node) {
        if (!StringUtils.isEmpty(node.getValue())) {
            // The Legacy FHH only supported identical twin status
            if (isBooleanInputTrue(node)) {
                p.setTwinStatus(TwinStatus.IDENTICAL);
            } else {
                p.setTwinStatus(TwinStatus.NO);
            }
        }
    }
    
    private static void setHTMGender(Person p, InputNode node) {
        p.setGender(Gender.fromHTMInputNode(node));
    }
    
    private static boolean isBooleanInputTrue(InputNode node) {
        return node.getValue().equals(YES) ? true : false;
    }
    
    /**
     * Processes the second set of relative nodes that can range from 0 or more relatives of one type.
     *  This includes all relatives other than parents and grandparents.
     * @param p <code>Person</code> to store relatives
     * @param node <code>HTMNode</code> containing InputNode objects to process.
     * @param familyAddConditions the list of family conditions
     */
    public static void processVariableRelativeNodes(Person p, HTMNode node, List<Disease> familyAddConditions) {
        List<InputNode> inputNodes = node.getInputNodes();
        List<HTMNode> variableRelatives;
        setHTMWeight(p, inputNodes.remove(0));
        setHTMHeight(p, inputNodes.remove(0));
        setHTMDateOfBirth(p, inputNodes.remove(0));
        
        variableRelatives = seperateVariableRelatives(inputNodes);
        for (HTMNode currNode : variableRelatives) {
            Relative currRelative = processRelativeAttributes(p, currNode, familyAddConditions);
            processVariableRelativeAttributes(currRelative, p, currNode);
        }
    }
    
    /**
     * Processes an <code>HTMNode</code> object associated with a variable relative and stores the
     *  information in the <code>Relative</code> object and links the relative to parent relatives
     *  for cousins and half siblings. A variable relative is a relative in which there can be 0 or 
     *  more of (any relative other than parents, grandparents).
     * @param relative the <code>Relative</code> object
     * @param root the root Person in the tree
     * @param node the <code>HTMNode</code> containing information about Self.
     */
    public static void processVariableRelativeAttributes(Relative relative, Person root, HTMNode node) {
        String parentValue = node.getInputNodes().get(PARENT_INDEX).getValue();
        // Drop the relative from the tree if no parent is specified
        if (StringUtils.isBlank(parentValue)) {
            root.getRelatives().remove(relative);
            root.getHtmImportDroppedRelatives().add(relative);
        } else if (!StringUtils.equals(CALCULATED, parentValue)) {
            linkParentToChild(relative, root, parentValue);
        }
    }
    
    private static void linkParentToChild(Relative relative, Person root, String parentValue) {
        RelativeCode parentCode = FormatUtils.convertLegacyCodeToRelativeCode(parentValue);
        Relative parent;
        int parentNum = PersonUtils.getParentNum(parentValue, parentCode);
        int firstOccurence = 0;
        // Find the first occurrence of a relative with the parent relative type
        for (Relative currRelative : root.getRelatives()) {
            if (currRelative.getCodeEnum().equals(parentCode)) {
                break;
            }
            firstOccurence++;
        }
        // The parent is located at index x-1 where x is the first location of the parent
        // relative type + parentNum
        parent = root.getRelatives().get(firstOccurence + parentNum - 1);
        if (parentCode.isMale()) {
            relative.setFather(parent);
        } else {
            relative.setMother(parent);
        }
        // If code is cousin, set code as paternal cousin or maternal cousin
        if (RelativeCode.COUSN.equals(relative.getCodeEnum())) {
            if (PersonUtils.isMothersSibling(parentCode)) {
                relative.setCode(RelativeCode.MCOUSN.toString());
            } else {
                relative.setCode(RelativeCode.PCOUSN.toString());
            }
            
        }
    }
    
    private static void setHTMWeight(Person p, InputNode node) {
        if (!StringUtils.isBlank(node.getValue())) {
            p.setWeight(new Weight(Integer.valueOf(node.getValue()), WeightUnit.US));
        }
    }
    
    private static void setHTMHeight(Person p, InputNode node) {
        if (!StringUtils.isBlank(node.getValue())) {
            p.setHeight(new Height(Integer.valueOf(node.getValue()), HeightUnit.US));
        }
    }
    
    private static void setHTMDateOfBirth(Person p, InputNode node) {
        if (!StringUtils.isBlank(node.getValue())) {
            p.setDateOfBirth((FormatUtils.convertAgeToDOB(Integer.valueOf(node.getValue()))));
        }
    }
    
    /**
     * Separates variable relative (relatives in which there may be 0 or more) <code>InputNode</code> 
     *  objects into separate <code>HTMNode</code> objects. These relatives do not include parent and
     *  grandparent nodes (already processed).
     * @param inputNodes List of <code>InputNode</code> objects containing information about 
     * @return List of <code>HTMNode</code> objects, each containing <code>InputNode</code> objects associated
     *  with a single relative
     */
    public static List<HTMNode> seperateVariableRelatives(List<InputNode> inputNodes) {
        List<HTMNode> variableRelatives = new ArrayList<HTMNode>();
        int daughters = getNumRelatives(inputNodes);
        int sons =  getNumRelatives(inputNodes);
        int sisters = getNumRelatives(inputNodes);
        int brothers = getNumRelatives(inputNodes);
        int halfSisters = getNumRelatives(inputNodes);
        int halfBrothers = getNumRelatives(inputNodes);
        int fathersSisters = getNumRelatives(inputNodes);
        int fathersBrothers = getNumRelatives(inputNodes);
        int mothersSisters = getNumRelatives(inputNodes);
        int mothersBrothers = getNumRelatives(inputNodes);
        int nieces = getNumRelatives(inputNodes);
        int nephews = getNumRelatives(inputNodes);
        int femaleCousins = getNumRelatives(inputNodes);
        int maleCousins = getNumRelatives(inputNodes);
        
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.DAU, daughters));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.SON, sons));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.NSIS, sisters));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.NBRO, brothers));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.HSIS, halfSisters));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.HBRO, halfBrothers));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.PAUNT, fathersSisters));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.PUNCLE, fathersBrothers));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.MAUNT, mothersSisters));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.MUNCLE, mothersBrothers));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.NIECE, nieces));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.NEPHEW, nephews));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.COUSN, femaleCousins));
        variableRelatives.addAll(seperateRelativeType(inputNodes, RelativeCode.COUSN, maleCousins));
        
        return variableRelatives;
    }
    
    private static Integer getNumRelatives(List<InputNode> nodes) {
        return Integer.valueOf(nodes.remove(0).getValue());
    }
    
    private static List<HTMNode> seperateRelativeType(List<InputNode> inputNodes, RelativeCode type, 
            int numRelatives) {
        List<HTMNode> relatives = new ArrayList<HTMNode>();
        if (numRelatives > 0) {
            for (int i = 0; i < numRelatives; i++) {
                relatives.add(new HTMNode(type, i + 1));
            }

            // The legacy input is inconsistent throughout the file. For each variable relative type, one attribute 
            // for each relative is displayed at a time until the disease listing. Example: brother1Name, brother2Name, 
            // brother1Gender, brother2Gender
            for (int i = 0; i < numRelatives * HEART_DISEASE_INDEX; i++) {
                relatives.get(i % numRelatives).getInputNodes().add(inputNodes.remove(0));
            }
            
            // One pair of Disease/onset pairs for one particular disease is displayed for all relatives of the same
            // typeat a time. Example: brother1Diabetes, brother1DiabetesOnset, brother2Diabetes, brother2DiabetesOnset
            processRelativeConditions(inputNodes, type, numRelatives, relatives);
        }
        return relatives;
    }
    
    private static void processRelativeConditions(List<InputNode> inputNodes, RelativeCode type, int numRelatives,
            List<HTMNode> relatives) {
        String htmValue = type.getHtmValue();
        // Handle legacy female and male cousins.  The legacy import stores female and male cousins separately.
        if (RelativeCode.COUSN.equals(type)) {
            if (StringUtils.contains(inputNodes.get(0).getName(), FEMALE)) {
                htmValue = FEMALE;
            } else {
                htmValue = MALE;
            }
        }
        while (!inputNodes.isEmpty() && inputNodes.get(0).getName().startsWith(htmValue)) {
            for (int i = 0; i < numRelatives; i++) {
                relatives.get(i).getInputNodes().add(inputNodes.remove(0));
                relatives.get(i).getInputNodes().add(inputNodes.remove(0));
            }
        }
    }
    
    /**
     * Generates a list of additional conditions for the family from the last input node from the legacy import.
     * @param node <code>InputNode</code> to process
     * @return list of diseases
     */
    public static List<Disease> processFamilyAddConditions(InputNode node) {
        List<Disease> conditions = new ArrayList<Disease>();
        String[] diseases = StringUtils.split(node.getValue(), ',');
        for (String currDisease : diseases) {
            conditions.add(DiseaseUtils.findOrCreateNewDisease(currDisease));
        }
        return conditions;
    }
}
