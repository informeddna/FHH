/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.service.util;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.GeneralPath;

/**
 * Helper class to draw some common shapes for the pedigree.
 * @author hniedner
 *
 */
public class ShapeUtil {

    /** 
     * left pointing arrow 16 x 16.
     */
    public static final int SIZE = 16;
    
    /** 
     * Increment for drawing the arrow.
     */
    public static final int INCREMENT_FRACTION = 4;

    /**
     *  Default color for Arrow.
     */
    public static final Color COLOR = new Color(50, 205, 50);

    /**
     * 
     * @param g2d - Java 2GGraphics component
     * 
     * @param posX - x start coordinate
     * 
     * @param posY - y start coordinate
     */
    public static void drawLeftDirectedArrow(final Graphics2D g2d, final int posX, final int posY) {
        doDrawArrow(g2d, createLeftArrow(posX, posY, SIZE));
    }

    /**
     * 
     * @param g2d - Java 2GGraphics component
     * 
     * @param posX - x start coordinate
     * 
     * @param posY - y start coordinate
     */
    public static void drawRightDirectedArrow(final Graphics2D g2d, final int posX, final int posY) {
        doDrawArrow(g2d, createRightArrow(posX, posY, SIZE));
    }

    private static void doDrawArrow(final Graphics2D g2d, final Shape arrow) {
        g2d.setPaintMode();
        final Color org = g2d.getColor();
        g2d.setColor(COLOR);
        g2d.fill(arrow);
        g2d.setColor(Color.BLACK);
        g2d.draw(arrow);
        g2d.setColor(org);
    }

    /**
     * 
     * @param startX - x start coordinate
     * 
     * @param startY - y start coordinate
     * 
     * @param size - of the error (height == width)
     * 
     * @return right pointing arrow.
     */
    public static Shape createRightArrow(final int startX, final int startY, final int size) {
        final GeneralPath arrow = new GeneralPath();
        // start
        arrow.moveTo(startX, startY);

        // up 1/2 and over 1/2
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX() + size / 2), new Float(arrow.getCurrentPoint().getY()
                - size / 2));

        // down 1/4 and fixed
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX()), new Float(arrow.getCurrentPoint().getY()
                + size / INCREMENT_FRACTION));

        // fixed and over 1/2
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX() + size / 2), new Float(arrow.getCurrentPoint().getY()));

        // down 1/2 and fixed
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX()), new Float(arrow.getCurrentPoint().getY() + size / 2));

        // fixed and back 1/2
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX() - size / 2), new Float(arrow.getCurrentPoint().getY()));

        // up 1/4 and fixed
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX()), new Float(arrow.getCurrentPoint().getY()
                + size / INCREMENT_FRACTION));

        // back to start
        arrow.lineTo(startX, startY);

        return arrow;
    }

    /**
     * 
     * @param startX - x start coordinate
     * 
     * @param startY - y start coordinate
     * 
     * @param size - of the error (height == width)
     * 
     * @return left pointing arrow.
     */
    public static Shape createLeftArrow(final int startX, final int startY, final int size) {
        final GeneralPath arrow = new GeneralPath();
        // start
        arrow.moveTo(startX, startY);

        // up 1/2 and over 1/2
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX() - size / 2), new Float(arrow.getCurrentPoint().getY()
                - size / 2));

        // down 1/4 and fixed
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX()), new Float(arrow.getCurrentPoint().getY()
                + size / INCREMENT_FRACTION));

        // fixed and over 1/2
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX() - size / 2), new Float(arrow.getCurrentPoint().getY()));

        // down 1/2 and fixed
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX()), new Float(arrow.getCurrentPoint().getY() + size / 2));

        // fixed and back 1/4
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX() + size / 2), new Float(arrow.getCurrentPoint().getY()));

        // up 1/4 and fixed
        arrow.lineTo(new Float(arrow.getCurrentPoint().getX()), new Float(arrow.getCurrentPoint().getY()
                + size / INCREMENT_FRACTION));

        // back to start
        arrow.lineTo(startX, startY);

        return arrow;
    }
}
