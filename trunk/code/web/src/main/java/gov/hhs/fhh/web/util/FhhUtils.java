/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services (“HHS”) hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the “software”) and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.web.util;

import gov.hhs.fhh.data.Person;
import gov.hhs.fhh.data.Relative;
import gov.hhs.fhh.data.RelativeCode;
import gov.hhs.fhh.data.util.FormatUtils;
import gov.hhs.fhh.data.util.PersonUtils;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import org.apache.commons.lang.StringUtils;

/**
 * @author bpickeral
 * Contains universal methods used in gov.hhs.web.* Most of the functions are tested in the methods in which 
 * the functions are called.
 */
@SuppressWarnings("PMD.CyclomaticComplexity")
public final class FhhUtils {
    
    private static final Integer INCHES_PER_FOOT = 12;
    
    /**
     * Function generates a list of valid relative codes that can be added to the 
     * family tree.   
     * @param existingCodes Existing relative codes in the tree
     * @return List of valid relatives the user can add to the tree
     */
    public static List<RelativeCode> generateValidRelativeList(List<String> existingCodes) {
        List<RelativeCode> relativeCodes = new ArrayList<RelativeCode>();
        addRelativesAlwaysDisplayed(relativeCodes);
        addConditionalRelatives(existingCodes, relativeCodes);
        return relativeCodes;
    }
    
    /**
     * Method Adds relatives that the user should always be able to add to their family Tree.
     * @param relativeCodes list to add relative codes
     */
    private static void addRelativesAlwaysDisplayed(List<RelativeCode> relativeCodes) {
        // Since the Mother and Father are automatically added to the family tree,
        // add all relatives directly linked to the Mother and Father.
        relativeCodes.add(RelativeCode.AUNT);
        relativeCodes.add(RelativeCode.UNCLE);
        relativeCodes.add(RelativeCode.DAU);
        relativeCodes.add(RelativeCode.SON);
        relativeCodes.add(RelativeCode.NBRO);
        relativeCodes.add(RelativeCode.NSIS);
    }
    
    /**
     * Function generates a list of valid relative codes that can be added to the 
     * family tree.  Cousins, nieces, nephews, and grandchildren must have a parent added
     * in the system before the user can add them to the tree.  
     * @param existingCodes List of existing relative codes in the tree
     * @param relativeCodes list of vaid relative codes that can be added to the tree
     */
    private static void addConditionalRelatives(List<String> existingCodes,
            List<RelativeCode> relativeCodes) {
        // Add Cousin if an Aunt or Uncle exists in the Tree
        if (existingCodes.contains(RelativeCode.MAUNT.toString())
                || existingCodes.contains(RelativeCode.MUNCLE.toString())
                || existingCodes.contains(RelativeCode.PAUNT.toString())
                || existingCodes.contains(RelativeCode.PUNCLE.toString())) {
            relativeCodes.add(RelativeCode.COUSN);
        }
        // Add Niece and Nephew if Siblings or Half siblings exist in the tree
        if (existingCodes.contains(RelativeCode.NBRO.toString())
                || existingCodes.contains(RelativeCode.NSIS.toString())
                || existingCodes.contains(RelativeCode.HBRO.toString())
                || existingCodes.contains(RelativeCode.HSIS.toString())) {
            relativeCodes.add(RelativeCode.NIECE);
            relativeCodes.add(RelativeCode.NEPHEW);
        }
        // Add Grandchildren if Son or Daughter exists in the Tree
        if (existingCodes.contains(RelativeCode.SON.toString())
                || existingCodes.contains(RelativeCode.DAU.toString())) {
            relativeCodes.add(RelativeCode.GRNDAU);
            relativeCodes.add(RelativeCode.GRNSON);
        }
        addImmediateConditionalRelatives(existingCodes, relativeCodes);
    }
    
    /**
     * Sub method of addConditionalRelatives. Handles Mother, Father, and half siblings.
     * @param existingCodes List of existing relative codes in the tree
     * @param relativeCodes list of vaid relative codes that can be added to the tree
     */
    private static void addImmediateConditionalRelatives(List<String> existingCodes,
            List<RelativeCode> relativeCodes) {
        // Add Mother if Mother is not yet added to the tree
        if (!existingCodes.contains(RelativeCode.NMTH.toString())) {
            relativeCodes.add(RelativeCode.NMTH);
        }
        // Add Father if Father is not yet added to the tree
        if (!existingCodes.contains(RelativeCode.NFTH.toString())) {
            relativeCodes.add(RelativeCode.NFTH);
        }
        // Add Half Siblings if Mother or Father exists in the Tree
        if (existingCodes.contains(RelativeCode.NMTH.toString())
                || existingCodes.contains(RelativeCode.NFTH.toString())) {
            relativeCodes.add(RelativeCode.HBRO);
            relativeCodes.add(RelativeCode.HSIS);
        }
    }
    
    /**
     * Method returns a list of Relative codes (coresponding to relatives) that 
     * are currently in the family tree.
     * @param relatives relatives to get codes
     * @return list of relative codes
     */
    public static List<String> getExistingCodes(List<Relative> relatives) {
        List<String> existingCodes = new ArrayList<String>();
        for (Relative relative : relatives) {
            if (!existingCodes.contains(relative.getCode())) {
                existingCodes.add(relative.getCode());
            }
        }
        return existingCodes;
    }
    
    /**
     * Function generates a list of Relative Codes representing maternal
     * and paternal specifiers that the user can select for the given
     * relative code.
     * @param relativeCode the relative code used to generate list
     * @return List of valid relative codes that represent maternal or paternal 
     * specifiers for the given relative code.
     */
    public static List<RelativeCode> getRelationshipSpecifiers(String relativeCode) {
        List<RelativeCode> relationshipSpecifiers = new ArrayList<RelativeCode>();
        if (relativeCode.equals(RelativeCode.GRFTH.toString())
                || relativeCode.equals(RelativeCode.GRMTH.toString())
                || relativeCode.equals(RelativeCode.AUNT.toString())
                || relativeCode.equals(RelativeCode.UNCLE.toString())) {
            relationshipSpecifiers.add(RelativeCode.NMTH);
            relationshipSpecifiers.add(RelativeCode.NFTH);
        } 
        return relationshipSpecifiers;
    }
    
    /**
     * Function generates a list of Relatives that could be the parent of the relative
     * with code relativeCode.  Cousin, niece, nephew, grandchildren, half siblings must
     * specify parent.
     * @param relativeCode the relative code with possible parents
     * @param relatives relatives of their person object
     * @return List of valid relative codes that could be the parent of the relative with 
     * code relativeCode.
     */
    public static List<Relative> getParents(String relativeCode, List<Relative> relatives) {
        List<Relative> parents = new ArrayList<Relative>();
        if (!relatives.isEmpty()) {
            List<String> validCodes = new ArrayList<String>();
            if (relativeCode.equals(RelativeCode.COUSN.toString())) {
                validCodes.add(RelativeCode.MAUNT.toString());
                validCodes.add(RelativeCode.PAUNT.toString());
                validCodes.add(RelativeCode.MUNCLE.toString());
                validCodes.add(RelativeCode.PUNCLE.toString());
                parents = getParentsFromCodes(validCodes, relatives);
            } else if (relativeCode.equals(RelativeCode.NIECE.toString())
                    || relativeCode.equals(RelativeCode.NEPHEW.toString())) {
                validCodes.add(RelativeCode.NBRO.toString());
                validCodes.add(RelativeCode.NSIS.toString());
                validCodes.add(RelativeCode.HBRO.toString());
                validCodes.add(RelativeCode.HSIS.toString());
                parents = getParentsFromCodes(validCodes, relatives);
            } else if (relativeCode.equals(RelativeCode.GRNSON.toString())
                    || relativeCode.equals(RelativeCode.GRNDAU.toString())) {
                validCodes.add(RelativeCode.SON.toString());
                validCodes.add(RelativeCode.DAU.toString());
                parents = getParentsFromCodes(validCodes, relatives);
            } else if (relativeCode.equals(RelativeCode.HBRO.toString())
                    || relativeCode.equals(RelativeCode.HSIS.toString())) {
                validCodes.add(RelativeCode.NMTH.toString());
                validCodes.add(RelativeCode.NFTH.toString());
                parents = getParentsFromCodes(validCodes, relatives);
            }
        }
        return parents;
    }
    /**
     * Function generates a list of Relatives from the tree with the relative code
     * code1 or code2.
     * @param validCodes list of valid relative codes to add
     * @param relatives Relatives in the person object
     * @return List of Relatives with relative code code1 or code2
     */
    private static List<Relative> getParentsFromCodes(List<String> validCodes, 
            List<Relative> relatives) {
        List<Relative> parents = new ArrayList<Relative>();
        int i = 0;
        for (Relative currRelative : relatives) {
            if (validCodes.contains(currRelative.getCode())) {
                // Set the ID since we store the ID in the action in order to set
                // the parent of the relative after we add the relative
                currRelative.setId((long) i);
                parents.add(currRelative);
            }
            i++;
        }
        return parents;
    }
    
    /**
     * Calculates total height in inches using height supplied in feet and inches.
     * @param feetIn height in feet
     * @param inchesIn height in inches
     * @return Integer representing total inches
     */
    public static Integer calculateHeightUS(Integer feetIn, Integer inchesIn) {
        // Initialize local variables so we don't modify variables passed in
        Integer feet = feetIn;
        Integer inches = inchesIn;
        if (feet == null) {
            // If both feet and inches are not specified, do not store height
            if (inches == null) {
                return null;
            }
            feet = 0;
        } 
        if (inches == null) {
            inches = 0;
        }
        return feet * INCHES_PER_FOOT + inches;
    }
    
    /**
     * Calculates total height in inches using height supplied in feet and inches.
     * @param feet height in feet
     * @param inches height in inches
     * @return Integer representing total inches
     */
    public static Integer calculateHeightUS(String feet, String inches) {
        Integer feetInt = null;
        Integer inchesInt = null;
        if (!StringUtils.isEmpty(feet)) {
            feetInt = Integer.valueOf(feet);
        }
        if (!StringUtils.isEmpty(inches)) {
            inchesInt = Integer.valueOf(inches);
        }
        return calculateHeightUS(feetInt, inchesInt);
    }

    
    /**
     * Sets the the links to mother and father based on the motherId and fatherId set by Castor.
     * @param person the Person for whom parents and grandparents should be set up
     * @return Person with parents and grandparents set up
     */
    @SuppressWarnings("PMD.AvoidReassigningParameters")
    public static Person setupParents(Person person) {
        for (Relative currRelative : person.getRelatives()) {
            if (currRelative.getMotherId() != null) {
                currRelative.setMother(person.getRelatives().get(currRelative.getMotherId().intValue()));
            } else if (currRelative.getFatherId() != null) {
                currRelative.setFather(person.getRelatives().get(currRelative.getFatherId().intValue()));
            } else if (RelativeCode.NMTH.toString().equals(currRelative.getCode())) {
                person.setMother(currRelative);
            } else if (RelativeCode.NFTH.toString().equals(currRelative.getCode())) {
                person.setFather(currRelative);
            }
        }
        person = addMother(person);
        person = addFather(person);
        return person;
    }

    private static Person addFather(Person person) {
        if (person.getRelativeOfType(RelativeCode.NFTH) == null) {
            person.setFather(PersonUtils.addRelative(person, RelativeCode.NFTH));
        }
        if (person.getRelativeOfType(RelativeCode.PGRMTH) == null) {
            PersonUtils.addRelative(person, RelativeCode.PGRMTH);
        }
        if (person.getRelativeOfType(RelativeCode.PGRFTH) == null) {
            PersonUtils.addRelative(person, RelativeCode.PGRFTH);
        }
        return person;
    }

    private static Person addMother(Person person) {
        if (person.getRelativeOfType(RelativeCode.NMTH) == null) {
            person.setMother(PersonUtils.addRelative(person, RelativeCode.NMTH));
        }
        if (person.getRelativeOfType(RelativeCode.MGRMTH) == null) {
            PersonUtils.addRelative(person, RelativeCode.MGRMTH);
        }
        if (person.getRelativeOfType(RelativeCode.MGRFTH) == null) {
            PersonUtils.addRelative(person, RelativeCode.MGRFTH);
        } 
        return person;
    }
    
    /**
     * Checks a date string for valid date format (MM/DD/YYYY).  Does not allow lenient
     * parsing (must be an actual Calendar date).
     * @param date to check
     * @return true/false representing validity of date
     */
    public static boolean checkDateFormat(String date) {
        boolean isValid = true;
        try {
            SimpleDateFormat format = new SimpleDateFormat(FormatUtils.DATE_FORMAT_STRING, Locale.US);
            format.setLenient(false);
            format.parse(date);
        } catch (Exception e) {
            isValid = false;
        }
        return isValid;
    }
    
    
    /**
     * Adds Mother, father, and grandparents to the family tree.
     * @param p <code>Person</code> object that the relatives will be added to.
     */
    public static void addRequiredRelativesToTree(Person p) {
        p.setMother(PersonUtils.addRelative(p, RelativeCode.NMTH));
        p.setFather(PersonUtils.addRelative(p, RelativeCode.NFTH));
        PersonUtils.addRelative(p, RelativeCode.MGRMTH);
        PersonUtils.addRelative(p, RelativeCode.MGRFTH);
        PersonUtils.addRelative(p, RelativeCode.PGRMTH);
        PersonUtils.addRelative(p, RelativeCode.PGRFTH);
    }
}
