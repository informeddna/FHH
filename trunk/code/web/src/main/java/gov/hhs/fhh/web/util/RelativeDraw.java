/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services (ÒHHSÓ) hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the ÒsoftwareÓ) and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.web.util;

import gov.hhs.fhh.data.ClinicalObservation;
import gov.hhs.fhh.data.Disease;
import gov.hhs.fhh.data.Gender;
import gov.hhs.fhh.data.LivingStatus;
import gov.hhs.fhh.data.Person;
import gov.hhs.fhh.data.Relative;
import gov.hhs.fhh.data.RelativeCode;
import gov.hhs.fhh.data.util.DiseaseUtils;

import java.awt.Color;
import java.awt.Font;
import java.awt.Image;
import java.awt.Polygon;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.swing.ImageIcon;

import org.apache.commons.collections.map.MultiValueMap;
import org.apache.commons.collections.set.ListOrderedSet;

import com.opensymphony.xwork2.ActionSupport;

/**
 * @author lpower
 */
// CHECKSTYLE:OFF legacy code slightly updated
@SuppressWarnings({"PMD.ExcessiveClassLength","PMD.CyclomaticComplexity","PMD.TooManyMethods",
    "PMD.LooseCoupling","PMD.ExcessiveMethodLength","PMD.UnusedPrivateField","PMD.NPathComplexity",
    "PMD.AvoidReassigningParameters","PMD.CollapsibleIfStatements","PMD.UnusedLocalVariable",
    "PMD.NcssMethodCount","PMD.ImmutableField","PMD.TooManyFields",
    "PMD.SignatureDeclareThrowsException","PMD.AvoidThrowingRawExceptionTypes","PMD.SystemPrintln"})
public class RelativeDraw extends Relative {
    private static final long serialVersionUID = 1L;


    private int xLoc;
    private int yLoc;
    private boolean hasSpouse = false;

    private RelativeDraw spouse;

    private boolean autoDrawChildren = true;

    private Disease highlightDisease;
    private boolean highlighted;
    private boolean showNames = true;

    public final static int PERSONSIZE = 30;
    public final static int SPOUSEDISTANCE = 120;
    public final static int CHILDRENDISTANCE = 60;
    public final static int CHILDRENBARLENGTH = 30;
    public final static int SIBLINGSPACING = 70;

    
    private MultiValueMap parents = createMultiMap(); // person->their parents
    private MultiValueMap children = createMultiMap(); // person->their children
    private MultiValueMap siblings = createMultiMap(); // person->their siblings
    private List<RelativeDraw> kids = new ArrayList<RelativeDraw>();

    static Image circle;
    static Image circleFill;
    static Image circleFillProband;
    static Image probandArrow;

    static {
        URL resource = RelativeDraw.class.getClassLoader().getResource("circle.png");
        circle = new ImageIcon(resource).getImage();

        URL resource2 = RelativeDraw.class.getClassLoader().getResource("circle-fill.png");
        circleFill = new ImageIcon(resource2).getImage();
        
        URL resource3 = RelativeDraw.class.getClassLoader().getResource("circle-fill-proband.png");
        circleFillProband = new ImageIcon(resource3).getImage();
        
        URL resource4 = RelativeDraw.class.getClassLoader().getResource("arrow_left.gif");
        probandArrow = new ImageIcon(resource4).getImage();

    }

    /**
     * Copy constructor.
     * 
     * @param r the Relative object to copy from.
     */
    public RelativeDraw(Relative r) {
        super(r);
    }

    /**
     * Copy constructor.
     * 
     * @param r the Relative object to copy from.
     */
    public RelativeDraw(RelativeDraw r) {
        super(r);
        this.xLoc = r.getXLoc();
        this.yLoc = r.getYLoc();
        this.hasSpouse = r.isHasSpouse();
        this.spouse = r.getSpouse();
        this.autoDrawChildren = r.isAutoDrawChildren();
        this.autoDrawChildren = r.isAutoDrawChildren();
        this.highlightDisease = r.getHighlightDisease();
    }

    /**
     * @return the xLoc
     */
    public int getXLoc() {
        return xLoc;
    }

    /**
     * @param loc the xLoc to set
     */
    public void setXLoc(int loc) {
        xLoc = loc;
    }

    /**
     * @return the yLoc
     */
    public int getYLoc() {
        return yLoc;
    }

    /**
     * @param loc the yLoc to set
     */
    public void setYLoc(int loc) {
        yLoc = loc;
    }

    /**
     * @return the hasSpouse
     */
    public boolean isHasSpouse() {
        return hasSpouse;
    }

    /**
     * @param hasSpouse the hasSpouse to set
     */
    public void setHasSpouse(boolean hasSpouse) {
        this.hasSpouse = hasSpouse;
    }

    /**
     * @return the spouse
     */
    public RelativeDraw getSpouse() {
        return spouse;
    }

    /**
     * @param spouse the spouse to set
     */
    public void setSpouse(RelativeDraw spouse) {
        this.spouse = spouse;
        setHasSpouse(true);
    }

    /**
     * @return the autoDrawChildren
     */
    public boolean isAutoDrawChildren() {
        return autoDrawChildren;
    }

    /**
     * @param autoDrawChildren the autoDrawChildren to set
     */
    public void setAutoDrawChildren(boolean autoDrawChildren) {
        this.autoDrawChildren = autoDrawChildren;
    }

    /**
     * @return the highlightDisease
     */
    public Disease getHighlightDisease() {
        return highlightDisease;
    }

    /**
     * @param highlightDisease the highlightDisease to set
     */
    public void setHighlightDisease(Disease highlightDisease) {
        this.highlightDisease = highlightDisease;
    }

    /**
     * @return the showNames
     */
    public boolean isShowNames() {
        return showNames;
    }

    /**
     * @param showNames the showNames to set
     */
    public void setShowNames(boolean showNames) {
        this.showNames = showNames;
    }

    /**
     * @return the kids
     */
    public List<RelativeDraw> getKids() {
        return kids;
    }

    /**
     * @param kids the kids to set
     */
    public void setKids(List<RelativeDraw> kids) {
        this.kids = kids;
    }

    /**
     * Gets the width of this person's children (icons). Calls getChildrenWidth(RelativeDraw, boolean) with this
     * person's autoDraw setting.
     * 
     * @param p RelativeDraw whose children should be drawn
     * @return int width of this person' children
     */
    public int getChildrenWidth(RelativeDraw p) {
        return getChildrenWidth(p, p.isAutoDrawChildren());
    }

    /**
     * Gets the width of this person's children (icons).
     * 
     * @param p RelativeDraw whose children should be drawn
     * @param includeChildren boolean indicates whether children should be included
     */
    private int getChildrenWidth(RelativeDraw p, boolean includeChildren) {
        int ret = 0;
        if (p.getKids().size() == 0 || !includeChildren) {
            return PERSONSIZE + SIBLINGSPACING;
        }
        for (RelativeDraw rel: p.getKids()) {
            ret += (getChildrenWidth(rel));
        }
        return ret;
    }

    /**
     * Draws this person - calls to draw from outside the method typically call for a grandfather or father.
     * 
     * @param g the 2D image
     * @param x the x position of the person on the image
     * @param y the y position of the person on the image
     * @param r RelativeDraw whose children should be drawn
     * @param showNames boolean indicates whether names should be shown in the image
     */
    @SuppressWarnings("PMD.ExcessiveParameterList")
    public void draw(java.awt.Graphics2D g, int x, int y, RelativeDraw r, boolean showNames, Disease highlight) {
        r.setXLoc(x);
        r.setYLoc(y);
        if (r.getGender() == null) {
            boolean highlighted = writeDiseaseCheckHighlight(g, r, highlight);
            Polygon diamond = makeDiamond(x, y);
            if (highlighted) {
                g.setColor(getBlueHighlight());
                g.fillPolygon(diamond);
                g.setColor(Color.BLACK);
            } else if (r.getCode().equals(RelativeCode.SELF.toString())) {
                g.setColor(getYellowHighlight());
                g.fillPolygon(diamond);
                g.setColor(Color.BLACK);
            }
            g.drawPolygon(diamond);
            if (!r.isAutoDrawChildren()) {
                return;
            }
            drawChildrenOfFemaleOrNongendered(g, r, showNames, highlight);
        } else {
            if (r.getGender().equals(Gender.MALE)) {
                boolean highlighted = writeDiseaseCheckHighlight(g, r, highlight);
                if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    g.drawImage(probandArrow, x + PERSONSIZE, y + PERSONSIZE / 4, null);
                }
                if (highlighted) {
                    g.setColor(getBlueHighlight());
                    g.fillRect(x, y, PERSONSIZE, PERSONSIZE);
                    g.setColor(Color.BLACK);
                } else if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    g.setColor(getYellowHighlight());
                    g.fillRect(x, y, PERSONSIZE, PERSONSIZE);
                    g.setColor(Color.BLACK);
                }
                g.drawRect(x, y, PERSONSIZE, PERSONSIZE);
                if ((spouse != null && spouse != this) || (r.getSpouse() != null)) {
                    // exception for mother of the father - she shows up twice if drawn here
                    if (!spouse.getCodeEnum().equals(RelativeCode.NMTH)) {
                        spouse.draw(g, x + SPOUSEDISTANCE, y, spouse, showNames, highlight);
                    }
                } else {
                    r.spouse = this;
                    r.setHasSpouse(false);
                }
                if (r.getKids().size() > 0 && r.isAutoDrawChildren()) {
                    r.drawChildren(g, showNames, r, highlight);
                }
            } else { // This is a female
                boolean highlighted = writeDiseaseCheckHighlight(g, r, highlight);
                if (highlighted) {
                    g.drawImage(circleFill, x, y, null);
                } else if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    g.drawImage(circleFillProband, x, y, null);
                } else {
                    g.drawImage(circle, x, y, null);
                }
                if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    g.drawImage(probandArrow, x + PERSONSIZE, y + PERSONSIZE / 4, null);
                }
                if (!r.isAutoDrawChildren()) {
                    return;
                }
                drawChildrenOfFemaleOrNongendered(g, r, showNames, highlight);
            }
        }

        if (r.getLivingStatus() != null) {
            if (r.getLivingStatus().equals(LivingStatus.NO.toString())) {
                g.setColor(Color.RED);
                g.drawLine(x + PERSONSIZE, y, x, y + PERSONSIZE);
                g.setColor(Color.BLACK);
            }
        }
        g.getFontMetrics();
        final int codeLeftSpace = 10;
        final int codeRightSpace = 20;
        RelativeCode rc = RelativeCode.getByValue(r.getCode());
        ActionSupport support = new ActionSupport();
        String relativeDisplay = support.getText(rc.getResourceKey());
        // remove maternal and paternal for length
        if (relativeDisplay.startsWith("Paternal ") || relativeDisplay.startsWith("Maternal ")) {
            relativeDisplay = relativeDisplay.substring(9,relativeDisplay.length());
        }
        if (relativeDisplay.endsWith("por parte de madre") || relativeDisplay.endsWith("por parte de padre")) {
            relativeDisplay = relativeDisplay.substring(0, relativeDisplay.indexOf("por") - 1);
        }
        if (r.getCode().equals(RelativeCode.SELF.toString())) {
            g.setPaint(getRedHighlight());
        }
        g.drawString("[" + relativeDisplay + "]", x - codeLeftSpace, y + PERSONSIZE + codeRightSpace);
        if (r.getCode().equals(RelativeCode.SELF.toString())) {
            g.setColor(Color.BLACK);
        }
        if (showNames) {
            String displayName = r.getName();
            if (displayName != null) {
                if (displayName.length() > 15) {
                    displayName = displayName.subSequence(0, 12) + "...";
                }
            } else {
                displayName = " ";
            }
            g.drawString(displayName, x - codeLeftSpace, y + PERSONSIZE + codeRightSpace
                    + g.getFontMetrics().getHeight());
        }
    }

    /**
     * Returns the blue Color for highlighted diseases.
     * 
     * @return Color
     */
    private Color getBlueHighlight() {
        return new Color(140, 211, 247);
    }
    
    /**
     * Returns the yellow Color for highlighting proband.
     * 
     * @return Color
     */
    private Color getYellowHighlight() {
        return new Color(234, 237, 99);
    }
    
    /**
     * Returns the yellow Color for highlighting proband.
     * 
     * @return Color
     */
    private Color getRedHighlight() {
        return new Color(209, 35, 35);
    }

    /**
     * Calls to draw children of female or non-gendered relatives (aunts or siblings).
     * 
     * @param g 2D image
     * @param r RelativeDraw whose children should be drawn
     * @param showNames
     */
    private void drawChildrenOfFemaleOrNongendered(java.awt.Graphics2D g, RelativeDraw r, boolean showNames, Disease highlight) {
        // female aunt or sibling (no spouse) - draw children
        if (r.getKids().size() > 0) {
            r.spouse = this;
            r.setHasSpouse(false);
            r.drawChildren(g, showNames, r, highlight);
        }
    }

    /**
     * Make diamond for folks whose gender is unknown.
     * 
     * @param x starting point of this image
     * @param y starting point of this image
     */
    private Polygon makeDiamond(int x, int y) {
        Polygon diamond = new Polygon();
        // top
        diamond.addPoint(x + PERSONSIZE / 2, y);
        // right
        diamond.addPoint(x + PERSONSIZE, y + PERSONSIZE / 2);
        // bottom
        diamond.addPoint(x + PERSONSIZE / 2, y + PERSONSIZE);
        // left
        diamond.addPoint(x, y + PERSONSIZE / 2);
        return diamond;
    }

    /**
     * Method draws the children of this relative.
     * 
     * @param g 2D image to be drawn
     * @param showNames boolean indicates whether names will be printed on the chart
     * @param r RelaiveDraw whose children should be drawn
     */
    public void drawChildren(java.awt.Graphics2D g, boolean showNames, RelativeDraw r, Disease highlight) {
        // convert all descendants to RelativeDraws - shouldn't that have been done already?
        List<RelativeDraw> l = new ArrayList<RelativeDraw>(r.getKids());
        r.setAutoDrawChildren(true);
       
        java.awt.geom.Line2D.Double connectorLine;
        // connect the parents
        if ((!r.isHasSpouse()) || (spouse == this)) {
            spouse = this;
            r.setHasSpouse(false);
            connectorLine = new java.awt.geom.Line2D.Double((r.getXLoc() + r.getXLoc() + PERSONSIZE) / 2, r.getYLoc()
                    + PERSONSIZE, (r.getXLoc() + r.getXLoc() + PERSONSIZE) / 2, r.getYLoc() + PERSONSIZE / 2
                    + CHILDRENDISTANCE);
        } else {
            RelativeDraw spouse = (RelativeDraw) r.getSpouse();
            g.drawLine(r.getXLoc() + PERSONSIZE, r.getYLoc() + PERSONSIZE / 2, spouse.getXLoc(), spouse.getYLoc()
                    + PERSONSIZE / 2);
            connectorLine = new java.awt.geom.Line2D.Double((r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r
                    .getYLoc()
                    + PERSONSIZE / 2, (r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r.getYLoc()
                    + PERSONSIZE / 2 + CHILDRENDISTANCE);
        }
        g.draw(connectorLine);

        // no kids - here by mistake
        if (l.isEmpty()) {
            return;
        }
        // one child
        if (l.size() == 1) {
            // line to connect child to parent line
            g.drawLine((r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r.getYLoc() + PERSONSIZE / 2
                    + CHILDRENDISTANCE, (r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r.getYLoc()
                    + PERSONSIZE / 2 + CHILDRENDISTANCE + CHILDRENBARLENGTH);
            // get and draw the kid
            RelativeDraw kid = l.get(0);
            int kidX = ((r.getXLoc() + r.getSpouse().getXLoc()) / 2);
            int kidY = (r.getYLoc() + PERSONSIZE / 2 + CHILDRENDISTANCE + CHILDRENBARLENGTH);
            kid.draw(g, kidX, kidY, kid, showNames, highlight);
        } else {
            // more than one child
            int lineLength = r.getChildrenWidth(r) - PERSONSIZE - SIBLINGSPACING;
            // get the last child and see if that child has children - this sets the size of this child grouping
            if (l.get((l.size() - 1)).getKids().size() > 1) {
                if (l.get(0).getKids().size() > 1) {
                    lineLength -= (r.getChildrenWidth((RelativeDraw) l.get(0))) / 2 - PERSONSIZE / 2 - SIBLINGSPACING
                            / 2;
                }
                lineLength -= r.getChildrenWidth((RelativeDraw) (l.get(l.size() - 1))) / 2 - PERSONSIZE / 2
                        - SIBLINGSPACING / 2;
            }
            double lastChild = 0;
            for (int lcv = 0; lcv < l.size(); lcv++) {
                double childX = 0;
                if (lcv == 0) {
                    childX = connectorLine.getX1() - lineLength / 2;
                } else {
                    int lastWidth = r.getChildrenWidth(l.get(lcv - 1));
                    childX = lastChild + lastWidth / 2 + r.getChildrenWidth(l.get(lcv)) / 2;
                }
                java.awt.geom.Line2D.Double childBar = new java.awt.geom.Line2D.Double(childX, connectorLine.getY2(),
                        childX, connectorLine.getY2() + CHILDRENBARLENGTH);
                lastChild = childX;
                // draw the bar that connects all of the children
                g.draw(childBar);
                // now draw this child
                RelativeDraw drawChild = l.get(lcv);
                int kidX = ((int) ((int) (childBar.getX1() - PERSONSIZE / 2)));
                int kidY = ((int) (childBar.getY2()));
                drawChild.draw(g, kidX, kidY, drawChild, showNames, highlight);
            }
            int lineStart = ((RelativeDraw) l.get(0)).getXLoc() + PERSONSIZE / 2;
            int lineEnd = ((RelativeDraw) l.get(l.size() - 1)).getXLoc() + PERSONSIZE / 2;
            java.awt.geom.Line2D.Double crossLine = new java.awt.geom.Line2D.Double(lineStart, connectorLine
                    .getY2(), lineEnd, connectorLine.getY2());
            g.draw(crossLine);
            // draw the line between any twins - this could stand refactoring
            List<RelativeDraw> theTwins = new ArrayList<RelativeDraw>();
            for (RelativeDraw potentialTwin : r.getKids()) {
                if (potentialTwin.isTwin()) {
                    theTwins.add(potentialTwin);
                }
            }
            if (theTwins.size() >= 1) {
                drawTwinLines(g, theTwins);
            }
        }
    }

    /**
     * Find the mid-point between twin relatives.
     * 
     * @param m list of relatives who are twins
     */
    private static int findMidPoint(List<RelativeDraw> m) {
        RelativeDraw firstTwin = (m.get(0));
        RelativeDraw lastTwin = (m.get(m.size() - 1));
        return (firstTwin.getXLoc() + lastTwin.getXLoc()) / 2 + PERSONSIZE / 2;
    }

    /**
     * Draws the triangular lines for twin relationships.
     * 
     * @param g the 2D image
     * @param m list of relatives who are twins
     */
    public void drawTwinLines(java.awt.Graphics2D g, List<RelativeDraw> m) {
        int midPoint = findMidPoint(m);
        RelativeDraw firstTwin = (m.get(0));
        RelativeDraw lastTwin = (m.get(m.size() - 1));
        for (RelativeDraw twin : m) {
            g.drawLine(twin.getXLoc() + PERSONSIZE / 2, twin.getYLoc(), midPoint, twin.getYLoc() - CHILDRENBARLENGTH);
        }
        g.drawLine((firstTwin.getXLoc() + PERSONSIZE / 2 + midPoint) / 2, firstTwin.getYLoc() - CHILDRENBARLENGTH / 2,
                (lastTwin.getXLoc() + PERSONSIZE / 2 + midPoint) / 2, firstTwin.getYLoc() - CHILDRENBARLENGTH / 2);
    }

    

    /**
     * Organizes family and creates drawing for the proband.
     * 
     * @param self Person (proband) to be organized
     * @return byte[] to be drawn
     * @throws Exception 
     */
    public byte[] organizeFamilyTree(Person self) throws Exception  {
        try {

            RelativeDraw firstGen2 = null;
            RelativeDraw firstGen3 = null;
            Set<RelativeDraw> family = new ListOrderedSet();

                // Map family = new HashMap();
                List<Relative> maternalHalfSiblings = new ArrayList<Relative>();
                List<Relative> paternalHalfSiblings = new ArrayList<Relative>();
                List originalRelatives = self.getRelatives();
                List<RelativeDraw> relatives = new ArrayList(convertToRelativeDraw(originalRelatives));
                

                Relative proband = new Relative(self, RelativeCode.SELF);
                //RelativeDraw selfDraw = new RelativeDraw(proband);
                Relative pGrandfather = new Relative();
                Relative pGrandmother = new Relative();
                Relative mGrandfather = new Relative();
                Relative mGrandmother = new Relative();
                Relative dad = null;
                Relative mom = null;
                
                List<Relative> fatherSiblings = new ArrayList<Relative>();
                List<Relative> motherSiblings = new ArrayList<Relative>();
                
                boolean probandGrandkids = false;

                int cousinCount = 0; // used for determining size of drawing
                
                List<RelativeDraw> myRels = new ArrayList<RelativeDraw>(convertToRelativeDraw(self.getRelatives()));
                // go through the relatives and slap them into the sets
                for (Relative rel : self.getRelatives()) {
                    switch (rel.getCodeEnum()) {
                    case MAUNT:
                    case MUNCLE:
                        motherSiblings.add(rel);
                        addSiblings(self.getMother(), rel);
                        break;
                    case PAUNT:
                        fatherSiblings.add(rel);
                        addSiblings(self.getFather(), rel);
                        break;
                    case PUNCLE:
                        firstGen2 = new RelativeDraw(rel);
                        fatherSiblings.add(rel);
                        addSiblings(self.getFather(), rel);
                        break;
                    case MCOUSN:
                    case PCOUSN:
                        if (rel.getMother() != null) {
                            addParentChild(rel, rel.getMother());
                        } else {
                            addParentChild(rel, rel.getFather());
                        }
                        cousinCount++;
                        break;
                    case GRNDAU:
                        probandGrandkids = true;
                    case GRNSON:
                        probandGrandkids = true;
                    case NEPHEW:
                    case NIECE:
                        if (rel.getMother() != null) {
                            addParentChild(rel, rel.getMother());
                        } else {
                            addParentChild(rel, rel.getFather());
                        }                
                        break;
                    case HBRO:
                    case HSIS:
                        if (rel.getMother() != null) {
                            addParentChild(rel, rel.getMother());
                            maternalHalfSiblings.add(rel);
                        } else {
                            addParentChild(rel, rel.getFather());
                            paternalHalfSiblings.add(rel);
                        }                
                        break;
                    case DAU:
                    case SON:
                        addParentChild(rel, proband);
                        break;
                    case PGRFTH:
                        pGrandfather = rel;
                        addParentChild(self.getFather(), rel);
                        break;
                    case PGRMTH:
                        pGrandmother = rel;
                        break;
                    case MGRFTH:
                        mGrandfather = rel;
                        addParentChild(self.getMother(), rel);
                        break;
                    case MGRMTH:
                        mGrandmother = rel;
                        break;
                    case NBRO:
                        addParentChild(rel, self.getMother());
                        addParentChild(rel, self.getFather());
                        addSiblings(proband, rel);
                        break;
                    case NSIS:
                        addParentChild(rel, self.getMother());
                        addParentChild(rel, self.getFather());
                        addSiblings(proband, rel);
                        break;
                    case NFTH:
                        dad = rel;
                        addParentChild(proband, rel);
                        break;
                    case NMTH:
                        mom = rel;
                        break;
                        default:
                        throw new IllegalStateException("A specifier was encountered as relative code");    
                    }
                }

                if (firstGen2 == null) {
                    firstGen2 = new RelativeDraw(dad);
                }
                    
                RelativeDraw father = new RelativeDraw(dad);
                RelativeDraw selfDraw = new RelativeDraw(proband);
                
                boolean haveGrandkids = false;
                // organize my own kids and grandkids) as descendant of dad
                for (Relative myKid: getChildren(proband)) {
                    for (Relative myGrandkid: getChildren(myKid)) {
                        myKid.getDescendants().add(myGrandkid);
                        haveGrandkids = true;
                    }
                    RelativeDraw kid = new RelativeDraw(myKid);
                    kid.setKids(convertToRelativeDraw(myKid.getDescendants()));
                    selfDraw.getKids().add(kid);
                }
                // organize my siblings (and their kids) as descendants of dad
                // brothers on left, then proband, then sisters on right
                // set first and last siblings to account for half siblings
                RelativeDraw firstSibling = null;
                RelativeDraw lastSibling = null;
                ArrayList<RelativeDraw> holdingSisters = new ArrayList<RelativeDraw>();
                for (Relative r: getSiblings(proband)) {
                    for (Relative nieceNephew: getChildren(r)) {
                        r.getDescendants().add(nieceNephew);
                    }
                    RelativeDraw rel = new RelativeDraw(r);
                    rel.setKids(convertToRelativeDraw(r.getDescendants()));
                    if (r.getCodeEnum().equals(RelativeCode.NBRO)) {
                        if (firstSibling == null) {
                            firstSibling = rel;
                        }
                        father.getKids().add(rel);
                    }
                    else {
                        holdingSisters.add(rel);
                    }
                }
                // add self
                father.getKids().add(selfDraw);
                lastSibling = selfDraw;
                // add sisters
                father.getKids().addAll(holdingSisters);
                if (!holdingSisters.isEmpty()) {
                    lastSibling = holdingSisters.get(holdingSisters.size()-1);
                }
                if (firstSibling == null) {
                    firstSibling = selfDraw;
                }

                RelativeDraw paternalGrandfather = new RelativeDraw(pGrandfather);
                // organize father's siblings as descendants of paternal grandfather
                // brother on left, then sisters, and father on far right
                // father should be last
                for (Relative r: fatherSiblings) {
                    RelativeDraw rel = new RelativeDraw(r);
                    if (!r.getCodeEnum().equals(RelativeCode.NFTH)) {
                        for (Relative cousin: getChildren(r)) {
                            r.getDescendants().add(cousin);
                            rel.setKids(convertToRelativeDraw(r.getDescendants()));
                        }
                        paternalGrandfather.getKids().add(rel);
                    }
                }
                RelativeDraw mother = new RelativeDraw(mom);
                father.setSpouse(mother);
                // set father to not automatically draw children - we'll do this manually
                father.setAutoDrawChildren(false);
                paternalGrandfather.getKids().add(father);

                // organize mother's siblings as descendants of paternal grandfather
                // mother should be first
                RelativeDraw maternalGrandfather = new RelativeDraw(mGrandfather);
                maternalGrandfather.getKids().add(mother);
                for (Relative r: motherSiblings) {
                    if (!r.getCodeEnum().equals(RelativeCode.NMTH)) {
                        RelativeDraw rel = new RelativeDraw(r);
                        for (Relative cousin: getChildren(r)) {
                            r.getDescendants().add(cousin);
                            rel.setKids(convertToRelativeDraw(r.getDescendants()));
                        }
                        maternalGrandfather.getKids().add(rel);
                    }
                }

                RelativeDraw paternalGrandmother = new RelativeDraw(pGrandmother);
                RelativeDraw maternalGrandmother = new RelativeDraw(mGrandmother);
                paternalGrandfather.setSpouse(paternalGrandmother);
                maternalGrandfather.setSpouse(maternalGrandmother);
                

                int halfSiblingSpace = Math.max(paternalHalfSiblings.size(), maternalHalfSiblings.size()) * 2
                        * (PERSONSIZE + SIBLINGSPACING);
                
                


            // ---------------- Start Drawing -------------------------------------
            final int widthSpacer = 20;
            int width = paternalGrandfather.getChildrenWidth(paternalGrandfather)
                    + maternalGrandfather.getChildrenWidth(maternalGrandfather) + father.getChildrenWidth(father, true)
                    + (PERSONSIZE + SIBLINGSPACING) + SPOUSEDISTANCE + halfSiblingSpace + widthSpacer;

            int floatUnderSpace = 0;
            if (cousinCount == 0) {
                floatUnderSpace = Math.min(paternalGrandfather.getChildrenWidth(paternalGrandfather), maternalGrandfather
                        .getChildrenWidth(maternalGrandfather));
            }

            int height = 500;
            if (haveGrandkids) {
                height = 600;
            }
            int imageWidth = Math.max(width, 700);
            //int imageSize = width;

            java.awt.image.BufferedImage image = new java.awt.image.BufferedImage(imageWidth, height,
                    java.awt.image.BufferedImage.TYPE_INT_RGB);
            java.awt.Graphics2D g = (java.awt.Graphics2D) image.getGraphics();

            g.setColor(java.awt.Color.WHITE);
            g.fillRect(0, 0, imageWidth, height);
            g.setColor(java.awt.Color.BLACK);

            final int startSpacing = 50;
            int startPos = paternalGrandfather.getChildrenWidth(paternalGrandfather) / 2 + 10 - SPOUSEDISTANCE / 2;
            if (startPos < startSpacing) {
                startPos = startSpacing;
            }
            // if there are no brothers or paternal uncles and self has lots of kids we need to
            // move the drawing over.
            int firstGen2Shift = 0;
            int firstGen3Shift = 0;
            if (firstGen2.getKids().size() > 4) {
                firstGen2Shift = (firstGen2.getKids().size() - 2) * (PERSONSIZE + SIBLINGSPACING) / 2;
            }
            if (firstGen2.getKids().size() > 0) {
                ListOrderedSet l = (ListOrderedSet) firstGen2.getKids();
                firstGen3 = new RelativeDraw((RelativeDraw) l.get(0));
                if (firstGen3.getKids().size() > 4) {
                    firstGen3Shift = (firstGen3.getKids().size() - 2) * (PERSONSIZE + SIBLINGSPACING) / 2;
                }
            }
            startPos += firstGen2Shift + firstGen3Shift;
            final int yPos = 50;

            // need to set father NOT to autodraw!!!
            // father.spouse = mother;

            paternalGrandfather.setXLoc(startPos);
            paternalGrandfather.setYLoc(yPos);
            paternalGrandfather.draw(g, startPos, yPos, paternalGrandfather, this.showNames, getHighlightDisease());

            int mg = (paternalGrandfather.getXLoc())
                    + paternalGrandfather.getChildrenWidth(paternalGrandfather)
                    / 2
                    - PERSONSIZE
                    - SIBLINGSPACING
                    + paternalGrandfather.getChildrenWidth(maternalGrandfather)
                    / 2
                    + Math.max(paternalGrandfather.getChildrenWidth(father, true) + halfSiblingSpace - floatUnderSpace,
                            SPOUSEDISTANCE * 2 + PERSONSIZE);

            maternalGrandfather.setXLoc(mg);
            maternalGrandfather.setYLoc(yPos);
            maternalGrandfather.draw(g, mg, yPos, maternalGrandfather, this.showNames, getHighlightDisease());
            father.drawChildren(g, this.showNames, father, getHighlightDisease());

            // Draw half siblings
            for (RelativeDraw myrel : convertToRelativeDraw(paternalHalfSiblings)) {
                if (myrel.getCode().equals(RelativeCode.HBRO.toString())
                        || myrel.getCode().equals(RelativeCode.HSIS.toString())) {
                    myrel.draw(g, firstSibling.getXLoc() - RelativeDraw.SIBLINGSPACING - RelativeDraw.PERSONSIZE,
                            firstSibling.getYLoc(), myrel, this.showNames, getHighlightDisease());
                    // think need to add this to draw, but not sure - don't know how to get dad's x and y locations
                    java.awt.geom.Line2D.Double upline = new java.awt.geom.Line2D.Double(myrel.getXLoc()
                            + RelativeDraw.PERSONSIZE / 2, myrel.getYLoc(), father.getXLoc() + RelativeDraw.PERSONSIZE / 2,
                            father.getYLoc() + RelativeDraw.PERSONSIZE);
                    g.draw(upline);
                    firstSibling = myrel;
                }
            }
            for (RelativeDraw myrel : convertToRelativeDraw(maternalHalfSiblings)) {
                if (myrel.getCode().equals(RelativeCode.HBRO.toString())
                        || myrel.getCode().equals(RelativeCode.HSIS.toString())) {
                    myrel.draw(g, lastSibling.getXLoc() + RelativeDraw.SIBLINGSPACING + RelativeDraw.PERSONSIZE,
                            lastSibling.getYLoc(), myrel, this.showNames, getHighlightDisease());
                    // think need to add this to draw, but not sure - don't know how to get dad's x and y locations
                    java.awt.geom.Line2D.Double upline = new java.awt.geom.Line2D.Double(myrel.getXLoc()
                            + RelativeDraw.PERSONSIZE / 2, myrel.getYLoc(), mother.getXLoc() + RelativeDraw.PERSONSIZE / 2,
                            mother.getYLoc() + RelativeDraw.PERSONSIZE);
                    g.draw(upline);
                    lastSibling = myrel;
                }
            }
            PngEncoderB encoder = new PngEncoderB(image);
            encoder.setCompressionLevel(5);
            return encoder.pngEncode();
            
        }
        finally { 
            int x=0; 
        }
    }


    /**
     * Method converts list of Relative objects to RelativeDraw objects. Also assigns Gender to Relatives from which
     * Gender can be intuited from the RelativeCode (ex: aunt assumes female).
     * 
     * @return List of RelativeDraw
     */
    private List<RelativeDraw> convertToRelativeDraw(List<Relative> relatives) {
        List<RelativeDraw> r = new ArrayList<RelativeDraw>();
        for (Relative myrel : relatives) {
            myrel.setId(Long.valueOf(relatives.indexOf(myrel)));
            // assign gender in rd if we can intuit it
            if (myrel.getGender() == null
                    || (!myrel.getGender().equals(Gender.FEMALE) || (!myrel.getGender().equals(Gender.MALE)))) {
                getImpliedGender(myrel);
            }
            RelativeDraw rd = new RelativeDraw(myrel);
            r.add(rd);
        }
        return r;
    }

    /**
     * Method converts list of Relative objects to RelativeDraw objects. Also assigns Gender to Relatives from which
     * Gender can be intuited from the RelativeCode (ex: aunt assumes female).
     * 
     * @return List of RelativeDraw
     */
    private List<RelativeDraw> convertToRelativeDraw(Set<Relative> relatives) {
        List<RelativeDraw> r = new ArrayList<RelativeDraw>();
        for (Relative myrel : relatives) {
            // assign gender in rd if we can intuit it
            if (myrel.getGender() == null
                    || (!myrel.getGender().equals(Gender.FEMALE) || (!myrel.getGender().equals(Gender.MALE)))) {
                getImpliedGender(myrel);
            }
            RelativeDraw rd = new RelativeDraw(myrel);
            r.add(rd);
        }
        return r;
    }

    
    /**
     * @param myrel
     */
    private void getImpliedGender(Relative myrel) {
            if (myrel instanceof Relative && (myrel.getCodeEnum().getImpliedGender() != null)) {
                myrel.setGender(myrel.getCodeEnum().getImpliedGender());
            }
    }

    
    private void addSiblings(Relative sibling1, Person sibling2) {
        siblings.put(sibling1, sibling2);
        siblings.put(sibling2, sibling1);
    }
    
    private MultiValueMap createMultiMap() {
        return MultiValueMap.decorate(new HashMap<Object, Object>(), HashSet.class); // NOPMD
    }

    private void addParentChild(Relative child, Relative parent) {
        parents.put(child, parent);
        children.put(parent, child);
    }
    
    @SuppressWarnings("unchecked")
    private Set<Relative> getRelatives(MultiValueMap relMap, Relative rel) {
        Set<Relative> coll = (Set<Relative>) relMap.getCollection(rel);
        if (coll == null) {
            coll = new HashSet<Relative>();
        }
        return coll;
    }

    @SuppressWarnings("PMD.UnusedPrivateMethod")
    private Set<Relative> getChildren(Relative relative) {
        return getRelatives(children, relative);
    }

    private Set<Relative> getSiblings(Relative relative) {
        return getRelatives(siblings, relative);
    }
    
    

    /**
     * Method writes the diseases that this person has.
     * 
     * @param g the 2D image
     * @param r the RelativeDraw whose diseases will be shown
     * @param highlight the Disease to be highlighted
     * @return boolean whether this person has the highlighted disease
     */
    public boolean writeDiseaseCheckHighlight(java.awt.Graphics2D g, RelativeDraw r, Disease highlight) {
        boolean highlightMe = false;
        int textAdd = 8;
        int textSpacing = 9;
        int textStartSpacing = 30;
        Font f = g.getFont();
        g.setFont(new Font("Tahoma", Font.TRUETYPE_FONT, 10));
        int textPos = r.getYLoc() + textAdd;
        List<ClinicalObservation> diseases = r.getObservations();
        if (r.getGender() == null) {
            for (ClinicalObservation ci : diseases) {
                Disease d = ci.getDisease();
                if (DiseaseUtils.compareHighlightDisease(d, highlight)) {
                    highlightMe = true;
                }
                String abbrev = DiseaseUtils.getDiseaseAbbreviation(d);
                g.drawString(abbrev, r.getXLoc() - textStartSpacing, textPos);
                textPos += textSpacing;
            }
        } else {
            if (r.getGender().equals(Gender.FEMALE)) {
                for (ClinicalObservation ci : diseases) {
                    Disease d = ci.getDisease();
                    if (DiseaseUtils.compareHighlightDisease(d, highlight)) {
                        highlightMe = true;
                    }
                    String abbrev = DiseaseUtils.getDiseaseAbbreviation(d);
                    g.drawString(abbrev, r.getXLoc() + textAdd + PERSONSIZE, textPos);
                    textPos += textSpacing;
                }
            }
            if (r.getGender().equals(Gender.MALE)) {
                for (ClinicalObservation ci : diseases) {
                    Disease d = ci.getDisease();
                    if (DiseaseUtils.compareHighlightDisease(d, highlight)) {
                        highlightMe = true;
                    }
                    String abbrev = DiseaseUtils.getDiseaseAbbreviation(d);
                    g.drawString(abbrev, r.getXLoc() - textStartSpacing, textPos);
                    textPos += textSpacing;
                }
            }
        }
        g.setFont(f);
        return highlightMe;
    }


    /**
     * @param relatives list of this person's relatives
     * @param relative this relative whose children we're looking for
     */
    /*
    private Relative getChildren(List<Relative> relatives, Relative potentialParent) {
        for (Relative myrel : relatives) {
            myrel.setId(Long.valueOf(relatives.indexOf(myrel)));
            Relative parent = new Relative();
            if (myrel.getFather() != null) {
                parent = myrel.getFather();
            }
            if (myrel.getMother() != null) {
                parent = myrel.getMother();
            }
            if (parent != null && parent.equals(potentialParent)) {
                RelativeDraw rd = new RelativeDraw(myrel);
                potentialParent.getDescendants().add(rd);
            }
        }
        return potentialParent;
    } */
}
// CHECKSTYLE:ON
