/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services (“HHS”) hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the “software”) and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data;

import gov.hhs.fhh.data.util.AgeRangeFieldHandler;
import gov.hhs.fhh.data.util.DataEstimatedAgeNode;
import gov.hhs.fhh.data.util.htmimport.InputNode;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;



/**
 * Enumeration represents an age range for a clinical observation.
 * Note: Due to HHS XML restrictions, lowValue must be unique and not null.
 * @author bpickeral
 */
@SuppressWarnings({ "PMD.AvoidDuplicateLiterals", "PMD.ExcessiveParameterList" })
public enum AgeRange {
    
   /**
    * Age Range prebirth.
    */
   PREBIRTH("prebirth", null, null, null, "pre-birth", null),

   /**
    * Age Range newborn - 0-28 days.
    */
   NEWBORN("newborn", "day", "0", "28", null, null),

   /**
    * Age Range infancy - 29-729 days.
    */
   INFANCY("infancy", "day", "29", "729", null, "In infancy"),

   /**
    * Age Range in childhood - 2-9 years.
    */
   CHILDHOOD("childhood", "year", "2", "9", null, null),

   /**
    * Age Range in adolescence - 10-19 years.
    */
   ADOLESCENCE("adolescence", "year", "10", "19", null, "Before age 20"),

   /**
    * Age Range 20-29.
    */
   TWENTIES("twenties", "year", "20", "29", null, "At age 20-29"),

   /**
    * Age Range 30-39.
    */
   THIRTIES("thirties", "year", "30", "39", null, "At age 30-39"),

   /**
    * Age Range 40-49.
    */
   FORTIES("forties", "year", "40", "49", null, "At age 40-49"),

   /**
    * Age Range 50-59.
    */
   FIFTIES("fifties", "year", "50", "59", null, "At age 50-59"),

   /**
    * Age Range over 60.
    */
   SIXTIES("sixties", "year", "60", null, null, "60 and older"),
   
   /**
    * Age Range unknown.
    */
   UNKNOWN("unknown", null, null, null, "unknown", "Age unknown");
   
   private static final String RESOURCE_KEY_PREFIX = "ageRange.";
   private static final String YEAR = "year";
   private static Map<String, AgeRange> valueToTypeMap = new HashMap<String, AgeRange>();
   private static Map<String, AgeRange> lowValueToTypeMap = new HashMap<String, AgeRange>();
   private static Map<String, AgeRange> htmValueToTypeMap = new HashMap<String, AgeRange>();
   private static List<AgeRange> htmImportAgeRanges = new ArrayList<AgeRange>();

   private final String resourceKey;
   private final String unit;
   private final String lowValue;
   private final String highValue;
   private final String originalText;
   private final String htmValue;

   AgeRange(String resourceKey, String unit, String lowValue, String highValue, String originalText, 
           String htmValue) {
       this.resourceKey = resourceKey;
       this.unit = unit;
       this.lowValue = lowValue;
       this.highValue = highValue;
       this.originalText = originalText;
       this.htmValue = htmValue;
   }


   /**
    * @return the resource key that should be used to retrieve a label for this AgeRange in the UI
    */
   public String getResourceKey() {
       return RESOURCE_KEY_PREFIX + resourceKey;
   }

   /**
    * @return the unit
    */
   public String getUnit() {
       return unit;
   }

   /**
    * @return the lowValue
    */
   public String getLowValue() {
       return lowValue;
   }

   /**
    * @return the highValue
    */
   public String getHighValue() {
       return highValue;
   }
   
   /**
    * @return the originalText
    */
   public String getOriginalText() {
       return originalText;
   }
   
   /**
    * @return the htmValue
    */
   public String getHtmValue() {
       return htmValue;
   }
   
   /**
    * Returns the <code>AgeRange</code> corresponding to the given value. Returns null
    * for null value.
    *
    * @param value the value to match
    * @return the matching type.
    */
   public static AgeRange getByValue(String value) {
       checkType(value);
       return getValueToTypeMap().get(value);
   }
   
   /**
    * Checks to see that the value given is a legal <code>AgeRange</code> value.
    *
    * @param value the value to check;
    */
   public static void checkType(String value) {
       if (value != null && !getValueToTypeMap().containsKey(value)) {
           throw new IllegalArgumentException("No matching type for " + value);
       }
   }
   
   /**
    * Returns a map of display values that map to the coresponding age range Enums.
    * @return valueToTypeMap
    */
   private static Map<String, AgeRange> getValueToTypeMap() {
       if (valueToTypeMap.isEmpty()) {
           for (AgeRange age : values()) {
               valueToTypeMap.put(age.getResourceKey(), age);
           }
       }
       return valueToTypeMap;
   }
   
   /**
    * Returns the <code>AgeRange</code> corresponding to the given value. Returns null
    * for null value.
    *
    * @param value the value to match
    * @return the matching type.
    */
   public static AgeRange getByLowValue(String value) {
       checkLowValue(value);
       return getLowValueToTypeMap().get(value);
   }
   
   /**
    * Checks to see that the value given is a legal <code>AgeRange</code> value.
    *
    * @param value the value to check;
    */
   public static void checkLowValue(String value) {
       if (value != null && !getLowValueToTypeMap().containsKey(value)) {
           throw new IllegalArgumentException("No lowValue matching type for " + value);
       }
   }
   
   /**
    * Returns a map of display values that map to the coresponding age range Enums.
    * @return valueToTypeMap
    */
   private static Map<String, AgeRange> getLowValueToTypeMap() {
       if (lowValueToTypeMap.isEmpty()) {
           for (AgeRange age : values()) {
               lowValueToTypeMap.put(age.getLowValue(), age);
           }
       }
       return lowValueToTypeMap;
   }
   
   /**
    * Returns the <code>AgeRange</code> corresponding to the given htm value. Returns null
    * for null value or unmatched value.
    *
    * @param value the value to match
    * @return the matching type.
    */
   public static AgeRange getByHtmValue(String value) {
       return getHtmValueToTypeMap().get(value);
   }
   
   /**
    * Returns a map of htm values that map to the corresponding age range Enums.
    * @return valueToTypeMap
    */
   private static Map<String, AgeRange> getHtmValueToTypeMap() {
       if (htmValueToTypeMap.isEmpty()) {
           for (AgeRange age : values()) {
               if (age.getHtmValue() != null) {
                   htmValueToTypeMap.put(age.getHtmValue(), age);
               }
           }
       }
       return htmValueToTypeMap;
   }
   
   /**
    * Converts an age entered in the legacy input to an AgeRange.
    * @param node InputNode from legacy input containing a valid integer value in the value field
    * @return AgeRange
    */
   public static AgeRange fromHTMInputNode(InputNode node) {
       Integer age = Integer.valueOf(node.getValue());
       AgeRange previousAgeRange = AgeRange.INFANCY;
       AgeRange ageRange = null;
       Iterator<AgeRange> it = getHTMImportRanges().iterator();
       // Set value of age range to the previous age range if the value is lower than the low value of the 
       // current range
       while (it.hasNext() && ageRange == null) {
           AgeRange currAgeRange = it.next();
           if (age < Integer.valueOf(currAgeRange.lowValue)) {
               ageRange = previousAgeRange;
           }
           previousAgeRange = currAgeRange;
       }
       if (ageRange == null) {
           ageRange = AgeRange.SIXTIES;
       }
       return ageRange;
   }
   
   private static List<AgeRange> getHTMImportRanges() {
       // The legacy import only handled integer values for age ranges.
       if (htmImportAgeRanges.isEmpty()) {
           for (AgeRange ageRange : AgeRange.values()) {
               if (YEAR.equals(ageRange.getUnit())) {
                   htmImportAgeRanges.add(ageRange);
               }
           }
       }
       return htmImportAgeRanges;
   }
   /**
    * Return the AgeRange as a DataEstimatedAgeNode.
    * @return DataEstimatedAgeNode
    */
   public DataEstimatedAgeNode getAsDataEstimatedAgeNode() {
       DataEstimatedAgeNode ageNode = null;
       if (getOriginalText() != null) {
           ageNode = new DataEstimatedAgeNode(getOriginalText());
       } else {
           ageNode = new DataEstimatedAgeNode(getUnit(), getLowValue(),
                   getHighValue());
       }
       return ageNode;
   }
   
   /**
    * Converts DataEstimatedAgeNode to AgeRange.
    * @param dataEstimatedAgeNode DataEstimatedAgeNode containing AgeRange
    * @return AgeRange represented by the DataEstimatedAgeNode
    */
   public static AgeRange fromDataEstimatedAgeNode(DataEstimatedAgeNode dataEstimatedAgeNode) {
       AgeRangeFieldHandler handler = dataEstimatedAgeNode.getAgeRangeHandler();
       if (handler != null) {
           return AgeRange.getByLowValue(dataEstimatedAgeNode.getAgeRangeHandler()
                   .getLowValue());
       } else if (dataEstimatedAgeNode.getCodeNode().getOriginalText().equals(
               AgeRange.PREBIRTH.getOriginalText())) {
           return AgeRange.PREBIRTH;
       } else {
           return AgeRange.UNKNOWN;
       }
   }
}