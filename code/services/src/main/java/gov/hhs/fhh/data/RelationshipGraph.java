/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.map.MultiValueMap;

import com.fiveamsolutions.hl7.model.mfhp.Gender;

/**
 * @author dkokotov
 */
@SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.TooManyMethods" })
public class RelationshipGraph {
    private final MultiValueMap parents = createMultiMap(); // person->their parents
    private final MultiValueMap children = createMultiMap(); // person->their children
    private final MultiValueMap siblings = createMultiMap(); // person->their siblings

    /**
     * Create a new RelationshipGraph based on the given person and his relatives.
     * @param person the person to base the graph on
     */
    public RelationshipGraph(Person person) {
        buildGraph(person);
    }
    
    private MultiValueMap createMultiMap() {
        return MultiValueMap.decorate(new HashMap<Object, Object>(), HashSet.class); // NOPMD
    }
    
    @SuppressWarnings("unchecked")
    private Set<Person> getRelatives(MultiValueMap relMap, Person person) {
        Set<Person> coll = (Set<Person>) relMap.getCollection(person);
        if (coll == null) {
            coll = new HashSet<Person>();
        }
        return coll;
    }
    
    private Set<Person> getParents(Person person) {
        return getRelatives(parents, person);
    }

    private Set<Person> getChildren(Person person) {
        return getRelatives(children, person);
    }

    private Set<Person> getSiblings(Person person) {
        return getRelatives(siblings, person);
    }

    @SuppressWarnings("PMD.ExcessiveMethodLength")
    private void buildGraph(Person self) {
        for (Relative rel : self.getRelatives()) {
            switch (rel.getCodeEnum()) {
            case MAUNT:
            case MUNCLE:
                addSiblings(self.getMother(), rel);
                break;
            case PAUNT:
            case PUNCLE:
                addSiblings(self.getFather(), rel);
                break;
            case HBRO:
            case HSIS:
                addSiblings(self, rel);
                // intentional drop-through
            case MCOUSN:
            case PCOUSN:
            case GRNDAU:
            case GRNSON:
            case NEPHEW:
            case NIECE:
                if (rel.getMother() != null) {
                    addParentChild(rel, rel.getMother());
                } else {
                    addParentChild(rel, rel.getFather());
                }                
                break;
            case DAU:
            case SON:
                addParentChild(rel, self);
                break;
            case PGRFTH:
            case PGRMTH:
                addParentChild(self.getFather(), rel);
                break;
            case MGRFTH:
            case MGRMTH:
                addParentChild(self.getMother(), rel);
                break;
            case NBRO:
            case NSIS:
                addParentChild(rel, self.getMother());
                addParentChild(rel, self.getFather());
                addSiblings(self, rel);
                break;
            case NFTH:
            case NMTH:
                addParentChild(self, rel);
                break;
                default:
                throw new IllegalStateException("A specifier was encountered as relative code");    
            }
            
            // second pass - fill in missing relationships
            connectParentFamilyBranch(self.getMother());
            connectParentFamilyBranch(self.getFather());
            
            // connect my brothers/sisters as siblings of each other, and their children as siblings of each other
            Collection<Person> mySiblings = getSiblings(self);
            // we need to special case my siblings to properly deal with half and full siblings
            connectProbandSiblings(mySiblings);
            for (Person sibling : mySiblings) {
                connectSiblings(getChildren(sibling));
            }
            
            // connect my children as siblings of each other, and their children as siblings of each other
            Collection<Person> myChildren = getChildren(self);
            connectSiblings(myChildren);
            for (Person child : myChildren) {
                connectSiblings(getChildren(child));
            }
        }                
    }
    
    private void connectProbandSiblings(Collection<Person> sibs) {
        for (Person sibling1 : sibs) {
            for (Person sibling2 : sibs) {
                if (sibling1 == sibling2) {
                    continue;
                }
                Collection<Person> sib1parents = getParents(sibling1);
                Collection<Person> sib2parents = getParents(sibling2);
                // if either sibling is proband's full sibling, or both are half siblings on the same parent's side
                // then they are siblings. otherwise (if they are half-sibling on different parents' side), the're not
                if (sib1parents.size() == 2 || sib2parents.size() == 2
                        || sib1parents.iterator().next() == sib2parents.iterator().next()) {
                    addSiblings(sibling1, sibling2);
                }
            }
        }        
    }
    
    private void connectSiblings(Collection<Person> sibs) {
        for (Person sibling1 : sibs) {
            for (Person sibling2 : sibs) {
                if (sibling1 != sibling2) {
                    addSiblings(sibling1, sibling2);                    
                }
            }
        }
    }

    private void connectParentFamilyBranch(Relative parent) {
        Collection<Person> auntUncles = getSiblings(parent);
        Collection<Person> grandparents = getParents(parent);
        connectSiblings(auntUncles);
        for (Person auntUncle : auntUncles) {
            for (Person grandparent : grandparents) {
                addParentChild(auntUncle, grandparent);
            }
            Collection<Person> cousins = getChildren(auntUncle);
            connectSiblings(cousins);
            for (Person cousin : cousins) {
                addParentChild(cousin, auntUncle);
            }
        }
    }

    /**
     * Given a person in this graph, returns that person as a proband with list of relatives.
     * @param center person to center graph on
     * @return the person as proband with relatives
     */
    public Person centerOn(Person center) {
        Person newProband = new Person(center);

        // 1. parents
        Collection<Person> newProbandParents = getParents(center);
        addRelativesOfType(newProband, newProbandParents, RelativeCode.NFTH, RelativeCode.NMTH, true);
        Relative father = newProband.getRelativeOfType(RelativeCode.NFTH);
        if (father != null) {
            newProband.setFather(father);
        }
        Relative mother = newProband.getRelativeOfType(RelativeCode.NMTH);
        if (mother != null) {
            newProband.setMother(mother);
        }
        
        // 2. siblings (and nephiews)
        Collection<Person> newProbandSiblings = getSiblings(center);
        addSiblings(newProband, center, newProbandSiblings, father, mother);

        // 3. children (and grandchildren)
        addRelativesWithChildren(newProband, getChildren(center), RelativeCode.SON, RelativeCode.DAU,
                RelativeCode.GRNSON, RelativeCode.GRNDAU, true);
        
        // parental branches
        for (Person parent : newProbandParents) {
            boolean maternal = getEffectiveGender(parent) == Gender.FEMALE;
            // 4. grandparents
            addRelativesOfType(newProband, getParents(parent), RelativeCode.GRFTH, RelativeCode.GRMTH, maternal);
            // 5. aunts/uncles (with cousins)
            addRelativesWithChildren(newProband, getSiblings(parent), RelativeCode.UNCLE, RelativeCode.AUNT,
                    RelativeCode.COUSN, RelativeCode.COUSN, maternal);
        }        
        return newProband;
    }

    @SuppressWarnings("unchecked")
    private void addSiblings(Person newProband, Person center, Collection<Person> sibs, Relative father, 
            Relative mother) {
        // we need to figure out if they are siblings or half-siblings
        // they are half siblings if one side has both parents set, and the other does not (or they differ)
        // if both sides only have one parent set, then we cannot tell for sure if they are full siblings or half
        // siblings so we assume full siblings
        for (Person sib : sibs) {
            Relative sibRelative = null;
            if (areFullSiblings(center, sib)) {
                sibRelative = addRelativeOfType(newProband, sib, RelativeCode.NBRO, RelativeCode.NSIS, true, null);
            } else {
                Collection<Person> sharedParents = CollectionUtils.intersection(getParents(center), getParents(sib));
                Person sharedParent = !sharedParents.isEmpty() ? sharedParents.iterator().next() : null;
                Relative parentAsProbandRelative = null;
                if (sharedParent != null) {
                    parentAsProbandRelative = getEffectiveGender(sharedParent) == Gender.MALE ? father : mother;
                }
                sibRelative = addRelativeOfType(newProband, sib, RelativeCode.HBRO, RelativeCode.HSIS, true,
                        parentAsProbandRelative);
            }
            // nephews / nieces
            addRelativesOfType(newProband, getChildren(sib), RelativeCode.NEPHEW, RelativeCode.NIECE, sibRelative);
        }
    }
    
    private boolean areFullSiblings(Person sibling1, Person sibling2) {
        // they are half siblings if one side has both parents set, and the other does not 
        // if both sides have both parents set, we can assume they are the same as this would only be the
        // case for the original proband and his natural brothers / sisters
        // if both sides have only one parent set, then we can't tell if they are full or half siblings, so we assume
        // full
        int numSibling1Parents = getParents(sibling1).size();
        int numSibling2Parents = getParents(sibling2).size();
        return numSibling1Parents == numSibling2Parents;
    }
    
    @SuppressWarnings("PMD.ExcessiveParameterList")        
    private void addRelativesWithChildren(Person newProband, Collection<Person> relatives, RelativeCode maleType,
            RelativeCode femaleType, RelativeCode maleChildType, RelativeCode femaleChildType, boolean maternal) {
        for (Person rel : relatives) {
            Relative probandRelative = addRelativeOfType(newProband, rel, maleType, femaleType, maternal, null);
            addRelativesOfType(newProband, getChildren(rel), maleChildType, femaleChildType, maternal, 
                    probandRelative);
        }
    }

    private void addRelativesOfType(Person newProband, Collection<Person> newProbandRelatives, RelativeCode maleType,
            RelativeCode femaleType, Relative parent) {
        addRelativesOfType(newProband, newProbandRelatives, maleType, femaleType, true, parent);
    }

    private void addRelativesOfType(Person newProband, Collection<Person> newProbandRelatives,
            RelativeCode maleType, RelativeCode femaleType, boolean maternal) {        
        addRelativesOfType(newProband, newProbandRelatives, maleType, femaleType, maternal, null);
    }

    @SuppressWarnings("PMD.ExcessiveParameterList")        
    private void addRelativesOfType(Person newProband, Collection<Person> newProbandRelatives,
            RelativeCode maleType, RelativeCode femaleType, boolean maternal, Relative parent) {        
        if (newProbandRelatives == null) {
            return;
        }
        for (Person relative : newProbandRelatives) {
            addRelativeOfType(newProband, relative, maleType, femaleType, maternal, parent);
        }        
    }
    
    @SuppressWarnings("PMD.ExcessiveParameterList")        
    private Relative addRelativeOfType(Person newProband, Person relative, RelativeCode maleType,
            RelativeCode femaleType, boolean maternal, Relative parent) {
        Gender effectiveGender = getEffectiveGender(relative);
        RelativeCode relCode = effectiveGender == Gender.MALE ? maleType : femaleType;
        if (relCode.hasBranchSpecificVersion()) {
            relCode = relCode.getBranchSpecificVersion(maternal);
        }
        Relative recenteredRelative = new Relative(relative, relCode, true);
        newProband.getRelatives().add(recenteredRelative);
        if (parent != null) {
            if (getEffectiveGender(parent) == Gender.MALE) {

                recenteredRelative.setFather(parent);
            } else {
                recenteredRelative.setMother(parent);
            }
        }
        return recenteredRelative;
    }
    
    /**
     * Returns effective gender of given relative for purpose of determining relationship to new proband.
     * Effective gender is calculated as follows:
     * 1. look at gender implied by relationship to original proband (e.g. son implies male, niece female, etc).
     * if this is unambiguous, use that.
     * 2. look at actual gender of the relative. if this is non-null, use that.
     * 3. return female
     * @param relative the relative whose effective gender needs to be determined
     * @return the gender, using the procedure above
     */
    public Gender getEffectiveGender(Person relative) {
        if (relative instanceof Relative && ((Relative) relative).getCodeEnum().getImpliedGender() != null) {
            return ((Relative) relative).getCodeEnum().getImpliedGender();
        }
        if (relative.getGender() != null) {
            return relative.getGender();
        }
        return Gender.FEMALE;
    }
    
    private void addParentChild(Person child, Person parent) {
        parents.put(child, parent);
        children.put(parent, child);
    }

    private void addSiblings(Person sibling1, Person sibling2) {
        siblings.put(sibling1, sibling2);
        siblings.put(sibling2, sibling1);
    }
}
