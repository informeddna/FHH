/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services (“HHS”) hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the “software”) and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data;

import gov.hhs.fhh.data.util.ClinicalObservationsNode;
import gov.hhs.fhh.data.util.CodeNode;
import gov.hhs.fhh.data.util.FhhDataUtils;
import gov.hhs.fhh.data.util.PersonUtils;
import gov.hhs.fhh.data.util.ValueNode;
import gov.hhs.fhh.data.util.htmimport.HTMImportUtils;
import gov.hhs.fhh.data.util.htmimport.HTMNode;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.set.ListOrderedSet;
import org.hibernate.validator.Length;

/**
 * @author Scott Miller
 */
@SuppressWarnings({ "PMD.TooManyFields", "PMD.ExcessiveClassLength" })
public class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final int NAME_LENGTH = 255;
    private static final boolean TRUE = true;
    private static final boolean FALSE = false;
    
    /**
     * String representing true used by Castor.
     */
    protected static final String TRUE_STRING = "true";

    private Long id;
    private String name;
    private Date dateOfBirth;
    private Weight weight = new Weight();
    private Height height = new Height();
    private Gender gender;
    private List<Ethnicity> ethnicities = new ArrayList<Ethnicity>();
    private List<Race> races = new ArrayList<Race>();
    private boolean adopted = false;
    private List<ClinicalObservation> observations = new ArrayList<ClinicalObservation>();
    private List<Relative> relatives = new ArrayList<Relative>();
    // Form was filled out for relative. We set the originalText for gender if the form was not filled out in order
    // to set completedForm to false on import.
    private boolean completedForm = false;
    private boolean unmatchedCondition = false;
    private List<Relative> htmImportDroppedRelatives = new ArrayList<Relative>();

    // Links to Mother and Father Relatives
    // Set for only Proband, cousins, grandchildren, half-Siblings, nieces, nephews
    private Relative father;
    private Relative mother;

    private boolean consanguinityFlag = false;
    private TwinStatus twinStatus;

    private Set<Relative> descendants = new ListOrderedSet();
    
    private boolean xmlFileSaved;

    /**
     * Default constructor.
     */
    public Person() {
        super();
    }

    /**
     * Copy constructor.
     * 
     * @param p the Person object to copy from.
     */
    public Person(Person p) {
        super();
        this.id = p.getId();
        this.name = p.getName();
        this.dateOfBirth = p.getDateOfBirth();
        this.weight = new Weight(p.getWeight().getValue(), p.getWeight().getUnit());
        this.height = p.getHeight();
        this.gender = p.getGender();
        this.ethnicities = p.getEthnicities();
        this.races = p.getRaces();
        this.observations.addAll(p.getObservations());
        this.adopted = p.isAdopted();
        this.completedForm = p.isCompletedForm();
        this.relatives.addAll(p.getRelatives());
        this.twinStatus = p.getTwinStatus();
        this.unmatchedCondition = p.isUnmatchedCondition();
    }

    /**
     * Used by Castor to generate the Clinical Observation Node.
     * 
     * @return ClinicalObservationsNode
     */
    public ClinicalObservationsNode getClinicalObservationsNode() {
        ClinicalObservationsNode node = new ClinicalObservationsNode();
        for (ClinicalObservation currObservation : observations) {
            Disease currDisease = currObservation.getDisease();
            currObservation.setCode(new CodeNode(currDisease.getCode(), currDisease.getCodeSystemName(), currDisease
                    .getDisplayName(), currDisease.getId(), currDisease.getOriginalText()));
        }
        node.getObservations().addAll(observations);
        addAttributesAsObservations(node);
        return node;
    }

    /**
     * Add non-disease clinical observations to ClinicalObservationsNode.
     * 
     * @param node ClinicalObservationsNode to add observations
     */
    private void addAttributesAsObservations(ClinicalObservationsNode node) {
        if (adopted) {
            ClinicalObservation adoptedObs = new ClinicalObservation();
            adoptedObs.setCode(new CodeNode(ClinicalObservationCode.ADOPTED));
            node.getObservations().add(adoptedObs);
        }
        if (twinStatus != null && !TwinStatus.NO.equals(twinStatus)) {
            ClinicalObservation twinStatusObs = new ClinicalObservation();
            twinStatusObs.setCode(new CodeNode(twinStatus.getCode(), twinStatus.getCodeSystemName(), twinStatus
                    .getDisplayName()));
            node.getObservations().add(twinStatusObs);
        }
        addHeightAndWeightAsObservations(node);
        if (consanguinityFlag) {
            ClinicalObservation consanguinityObs = new ClinicalObservation();
            consanguinityObs.setCode(new CodeNode());
            consanguinityObs.getCode().setOriginalText(ClinicalObservationCode.CONSANGUINITY_ORG_TEXT);
            node.getObservations().add(consanguinityObs);
        }
    }

    private void addHeightAndWeightAsObservations(ClinicalObservationsNode node) {
        if (weight.getValue() != null) {
            ClinicalObservation weightObs = new ClinicalObservation();
            weightObs.setCode(new CodeNode(ClinicalObservationCode.WEIGHT));
            weightObs.setValueNode(new ValueNode(weight.getValue().toString(), weight.getUnit().getDisplayName()));
            node.getObservations().add(weightObs);
        }
        if (height.getValue() != null) {
            ClinicalObservation heightObs = new ClinicalObservation();
            heightObs.setCode(new CodeNode(ClinicalObservationCode.HEIGHT));
            heightObs.setValueNode(new ValueNode(height.getValue().toString(), height.getUnit().getDisplayName()));
            node.getObservations().add(heightObs);
        }
    }

    /**
     * Used by Castor to set the Clinical Observation Node.
     * 
     * @param node ClinicalObservationsNode
     */
    public void setClinicalObservationsNode(ClinicalObservationsNode node) {
        Map<Long, Disease> diseaseMap = FhhDataUtils.getIdToDiseaseMap();
        for (ClinicalObservation currObservation : node.getObservations()) {
            setupObservation(currObservation, diseaseMap);
        }
    }
    
    /**
     * Used by Castor to set the Person Object from the data within the input nodes.
     * 
     * @param node node htm node containing attributes
     */
    public void setHtmNode(HTMNode node) {
        // Store each set of input nodes associated with a single relative into an HTMNode
        List<HTMNode> relativeNodes = HTMImportUtils.seperateFixedRelatives(node);
        HTMNode remainingNodes = relativeNodes.get(HTMImportUtils.NUM_FIXED_RELATIVES);
        
        // Obtain the list of family additional conditions
        List<Disease> familyAddCondtitions = HTMImportUtils.processFamilyAddConditions(
                remainingNodes.getInputNodes().get(remainingNodes.getInputNodes().size() - 1));
        
        HTMImportUtils.processPersonAttributes(this, relativeNodes.get(0), familyAddCondtitions);
        relativeNodes.remove(HTMImportUtils.NUM_FIXED_RELATIVES);
        relativeNodes.remove(0);
        
        // Process Fixed relatives (parents, grandparents)
        for (HTMNode currNode : relativeNodes) {
            HTMImportUtils.processRelativeAttributes(this, currNode, familyAddCondtitions);
        }
        HTMImportUtils.processVariableRelativeNodes(this, remainingNodes, familyAddCondtitions);
        PersonUtils.setRelativeIds(getRelatives());
    }
    
    /**
     * Dummy Method needed by Castor.
     * @return new HTMNode
     */
    public HTMNode getHtmNode() {
        return new HTMNode();
    }

    /**
     * Stores information from clinicalObservation into the Person Object. Any information set must also be transfered
     * to the Relative in setRelationshipHolderNode.
     * 
     * @param observation observation containing code
     * @param diseaseMap map of ids to diseases
     */
    private void setupObservation(ClinicalObservation observation, Map<Long, Disease> diseaseMap) {
        CodeNode currCode = observation.getCode();
        if (currCode.getOriginalText() != null) {
            setupObservationWithOriginalText(observation, diseaseMap);
        } else if (currCode.getId() != null) {
            Disease matchingDisease = diseaseMap.get(currCode.getId());
            if (matchingDisease != null) {
                observation.setDisease(matchingDisease);
                observations.add(observation);
            } 
        } else {
            setupObservationWithoutId(observation);
        }
    }

    /**
     * Function Stores information from a ClinicalObservation with original text (User entered diseases and
     * consanguinity nodes).
     * 
     * @param observation observation containing code
     * @param diseaseMap map of ids to diseases
     */
    private void setupObservationWithOriginalText(ClinicalObservation observation, Map<Long, Disease> diseaseMap) {
        CodeNode currCode = observation.getCode();
        if (currCode.getOriginalText().equals(ClinicalObservationCode.CONSANGUINITY_ORG_TEXT)) {
            setConsanguinityFlag(TRUE);
        } else {
            Disease matchingDisease = diseaseMap.get(currCode.getId());
            if (matchingDisease != null) {
                Disease otherDisease = new Disease(diseaseMap.get(currCode.getId()));
                otherDisease.setOriginalText(currCode.getOriginalText());
                otherDisease.setAppDisplay(currCode.getOriginalText());
                observation.setDisease(otherDisease);
                observations.add(observation);
            }
        }
    }

    /**
     * Stores information from clinicalObservation (without ID) into the Person Object. Any information set must also be
     * transfered to the Relative in setRelationshipHolderNode.
     * 
     * @param currObservation observation containing code
     */
    private void setupObservationWithoutId(ClinicalObservation observation) {
        String code = observation.getCode().getCode();
        if (code.equals(ClinicalObservationCode.ADOPTED.getCode())) {
            setAdopted(TRUE);
        } else if (code.equals(ClinicalObservationCode.WEIGHT.getCode())) {
            setWeight(new Weight(Integer.valueOf(observation.getValueNode().getValue()), 
                    WeightUnit.fromUnit(observation.getValueNode().getUnit())));
        } else if (code.equals(ClinicalObservationCode.HEIGHT.getCode())) {
            setHeight(new Height(Integer.valueOf(observation.getValueNode().getValue()), 
                    HeightUnit.fromUnit(observation.getValueNode().getUnit())));
        } else if (code.equals(TwinStatus.IDENTICAL.getCode())) {
            setTwinStatus(TwinStatus.IDENTICAL);
        } else if (code.equals(TwinStatus.FRATERNAL.getCode())) {
            setTwinStatus(TwinStatus.FRATERNAL);
        }
    }

    /**
     * Returns boolean indicating if person is twin.
     * 
     * @return true if person is twin, otherwise false
     */
    public boolean isTwin() {
        boolean isTwin = false;
        if (twinStatus != null && !twinStatus.equals(TwinStatus.NO)) {
            isTwin = true;
        }
        return isTwin;
    }

    /**
     * Used by Castor to generate the deceased indicator node if the relative is deceased. Note: isDeceased should be
     * used outside of Castor as this function returns null in the case that the relative is alive.
     * 
     * @return true string if person is deceased, otherwise null
     */
    public String getMultipleBirthIndicator() {
        if (isTwin()) {
            return TRUE_STRING;
        }
        return null;
    }

    /**
     * Used for Castor serialization. Import uses the gender nodes original text value to find if the form was 
     *  completed for a relative (Gender is only required attribute). Set originalText if form was not completed. 
     *  If unmatched condition exists upon save, all unmatched conditions are validated (form completed).
     * 
     * @return the gender as a castor-serializable node.
     */
    public GenderNode getGenderNode() {
        return getGender() != null ? getGender().getAsGenderNode(isCompletedForm() || isUnmatchedCondition()) : null;
    }

    /**
     * Used for castor deserialization. Import uses the gender nodes original text value to find if the form was 
     *  completed for a relative (Gender is only required attribute).
     * 
     * @param genderNode the representation of the gender obtained from the castor-deserialized XML.
     */
    public void setGenderNode(GenderNode genderNode) {
        this.gender = Gender.fromGenderNode(genderNode);
        // We store displayName as originalText if form was not completed for person
        if (genderNode.getOriginalText() != null) {
            this.setCompletedForm(TRUE);
        } else {
            this.setCompletedForm(FALSE);
        }
    }

    /**
     * Get unit for height and weight - need inches and lbs OR meters and kg
     *   formula for inches and lbs.
     *   BMI = (weight in lbs * 703)/(height in inches)(height in inches).
     *   BMI = (weight in kg)/(height in meters).
     * @return the bmi
     */
    public String getBmi() {
        return PersonUtils.calculateBmi(this);
    }

    /**
     * @param relCode type of relatives to return
     * @return list of relatives of given type.
     */
    public List<Relative> getRelativesOfType(final RelativeCode relCode) {
        List<Relative> rels = new ArrayList<Relative>();
        for (Relative rel : this.relatives) {
            if (rel.getCodeEnum() == relCode) {
                rels.add(rel);
            }
        }
        return rels;
    }

    /**
     * @param relCode type of relative to return
     * @return the relative of given type, or null if no relatives of that type were found.
     */
    public Relative getRelativeOfType(final RelativeCode relCode) {
        List<Relative> rels = getRelativesOfType(relCode);
        if (rels.isEmpty()) {
            return null;
        }
        if (rels.size() == 1) {
            return rels.get(0);
        }
        throw new IllegalArgumentException("More than one relative of type " + relCode);
    }

    /**
     * @param relName name of relative to return
     * @return the first relative with given name, or null if no relatives with that name found
     */
    public Relative getRelativeByName(String relName) {
        for (Relative rel : this.relatives) {
            if (rel.getName().equals(relName)) {
                return rel;
            }
        }
        return null;
    }

    /**
     * recenters the family history on the relative with given index.
     * 
     * @param index index of relative on whom to recenter.
     * @return the person on whom the history has been recentered, with a properly populated list of relatives.
     */
    public Person recenterOn(int index) {
        RelationshipGraph relGraph = new RelationshipGraph(this);
        Relative centerRelative = this.relatives.get(index);
        return relGraph.centerOn(centerRelative);
    }

    /**
     * @return the list of race IDs
     */
    public List<Long> getRaceIds() {
        List<Long> raceIds = new ArrayList<Long>();
        for (Race currRace : races) {
            raceIds.add(currRace.getId());
        }
        return raceIds;
    }

    /**
     * @return the list of race IDs
     */
    public List<Long> getEthnicityIds() {
        List<Long> raceIds = new ArrayList<Long>();
        for (Ethnicity currEthnicity : ethnicities) {
            raceIds.add(currEthnicity.getId());
        }
        return raceIds;
    }
    
    /**
     * @return calculated age of this person
     */
    public int getMyAge() {
        int age = 0;
        if (this.getDateOfBirth() != null) {
            GregorianCalendar currCal = new GregorianCalendar();
            GregorianCalendar birthCal = new GregorianCalendar();
            birthCal.setTime(getDateOfBirth());
            age = currCal.get(Calendar.YEAR) - birthCal.get(Calendar.YEAR);
            if ((birthCal.get(Calendar.MONTH) > currCal.get(Calendar.MONTH)) 
                    || (birthCal.get(Calendar.MONTH) == birthCal.get(Calendar.MONTH)
                            && birthCal.get(Calendar.DAY_OF_MONTH) > currCal.get(Calendar.DAY_OF_MONTH))) {
                age--;
            }
        }
        return age;
    }

    /**
     * Used in familyHistoryDetail.jsp to find if the Proband or any of the relatives contained unmatched conditions
     *  after a legacy import (A user entered disease that did not match up with any FHH diseases).
     * @return boolean true if unmatched condition exists, otherwise false
     */
    public boolean isFamilyContainsUnmatchedCondition() {
        boolean unmatched = false;
        if (isUnmatchedCondition()) {
            unmatched = true;
        }
        for (Relative currRelative : getRelatives()) {
            if (currRelative.isUnmatchedCondition()) {
                unmatched = true;
            }
        }
        return unmatched;
    }
    
    /**
     * @return the gender
     */
    public Gender getGender() {
        return gender;
    }
    
    /**
     * @param gender the gender to set
     */
    public void setGender(Gender gender) {
        this.gender = gender;
    }
    
    /**
     * @return the id
     */
    public Long getId() {
        return this.id;
    }

    /**
     * @param id the id to set
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
     * @return the name
     */
    @Length(max = NAME_LENGTH)
    public String getName() {
        return this.name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return the dateOfBirth
     */
    public Date getDateOfBirth() {
        return dateOfBirth;
    }

    /**
     * @param dateOfBirth the dateOfBirth to set
     */
    public void setDateOfBirth(Date dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
    }

    /**
     * @return the adopted
     */
    public boolean isAdopted() {
        return adopted;
    }

    /**
     * @param adopted the adopted to set
     */
    public void setAdopted(boolean adopted) {
        this.adopted = adopted;
    }
    
    /**
     * @return the observations
     */
    public List<ClinicalObservation> getObservations() {
        return observations;
    }

    /**
     * @param observations the observations to set
     */
    public void setObservations(List<ClinicalObservation> observations) {
        this.observations = observations;
    }

    /**
     * @return the relatives
     */
    public List<Relative> getRelatives() {
        return relatives;
    }

    /**
     * @param relatives the relatives to set
     */
    public void setRelatives(List<Relative> relatives) {
        this.relatives = relatives;
    }
    
    /**
     * @return the completedForm
     */
    public boolean isCompletedForm() {
        return completedForm;
    }

    /**
     * @param completedForm the completedForm to set
     */
    public void setCompletedForm(boolean completedForm) {
        this.completedForm = completedForm;
    }

    /**
     * @return the father
     */
    public Relative getFather() {
        return father;
    }

    /**
     * @param father the father to set
     */
    public void setFather(Relative father) {
        this.father = father;
    }

    /**
     * @return the mother
     */
    public Relative getMother() {
        return mother;
    }

    /**
     * @param mother the mother to set
     */
    public void setMother(Relative mother) {
        this.mother = mother;
    }

    /**
     * @return the descendants
     */
    public Set<Relative> getDescendants() {
        return descendants;
    }

    /**
     * @param descendants the descendants to set
     */
    public void setDescendants(Set<Relative> descendants) {
        this.descendants = descendants;
    }
    
    /**
     * @return the races
     */
    public List<Race> getRaces() {
        return races;
    }

    /**
     * @param races the races to set
     */
    public void setRaces(List<Race> races) {
        this.races = races;
    }
    
    /**
     * @return the ethnicities
     */
    public List<Ethnicity> getEthnicities() {
        return ethnicities;
    }

    /**
     * @param ethnicities the ethnicities to set
     */
    public void setEthnicities(List<Ethnicity> ethnicities) {
        this.ethnicities = ethnicities;
    }
    
    /**
     * @return the consanguinityFlag
     */
    public boolean isConsanguinityFlag() {
        return consanguinityFlag;
    }

    /**
     * @param consanguinityFlag the consanguinityFlag to set
     */
    public void setConsanguinityFlag(boolean consanguinityFlag) {
        this.consanguinityFlag = consanguinityFlag;
    }

    /**
     * @return the twinStatus
     */
    public TwinStatus getTwinStatus() {
        return twinStatus;
    }

    /**
     * @param twinStatus the twinStatus to set
     */
    public void setTwinStatus(TwinStatus twinStatus) {
        this.twinStatus = twinStatus;
    }

    /**
     * @return the height
     */
    public Height getHeight() {
        return height;
    }

    /**
     * @param height the height to set
     */
    public void setHeight(Height height) {
        this.height = height;
    }

    /**
     * @return the unmatchedCondition
     */
    public boolean isUnmatchedCondition() {
        return unmatchedCondition;
    }

    /**
     * @param unmatchedCondition the unmatchedCondition to set
     */
    public void setUnmatchedCondition(boolean unmatchedCondition) {
        this.unmatchedCondition = unmatchedCondition;
    }

    /**
     * @return the htmImportDroppedRelatives
     */
    public List<Relative> getHtmImportDroppedRelatives() {
        return htmImportDroppedRelatives;
    }

    /**
     * @param htmImportDroppedRelatives the htmImportDroppedRelatives to set
     */
    public void setHtmImportDroppedRelatives(List<Relative> htmImportDroppedRelatives) {
        this.htmImportDroppedRelatives = htmImportDroppedRelatives;
    }

    /**
     * @return the weight
     */
    public Weight getWeight() {
        return weight;
    }

    /**
     * @param weight the weight to set
     */
    public void setWeight(Weight weight) {
        this.weight = weight;
    }

    /**
     * @return the xmlFileSaved
     */
    public boolean isXmlFileSaved() {
        return xmlFileSaved;
    }

    /**
     * @param xmlFileSaved the xmlFileSaved to set
     */
    public void setXmlFileSaved(boolean xmlFileSaved) {
        this.xmlFileSaved = xmlFileSaved;
    }
}
