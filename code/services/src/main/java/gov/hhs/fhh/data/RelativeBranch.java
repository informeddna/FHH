/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.collections.map.MultiValueMap;
import org.apache.commons.collections.set.ListOrderedSet;

import com.fiveamsolutions.hl7.model.mfhp.Gender;

/**
 * @author lpower
 * 
 */
@SuppressWarnings("PMD.CyclomaticComplexity")
public class RelativeBranch {

    private Set<Relative> fatherBranch = new ListOrderedSet();
    private Set<Relative> motherBranch = new ListOrderedSet();
    private Set<Relative> siblings = new ListOrderedSet();
    @SuppressWarnings("PMD.ImmutableField")
    private MultiValueMap parents = createMultiMap(); // person->their parents
    @SuppressWarnings("PMD.ImmutableField")
    private MultiValueMap children = createMultiMap(); // person->their children

    /**
     * Copy constructor.
     * 
     * @param p the Parent object to copy from.
     */
    public RelativeBranch(Person p) {
        if (!p.getRelatives().isEmpty()) {
            organizeTree(p);
        }
    }

    /**
     * @return the fatherBranch
     */
    public Set<Relative> getFatherBranch() {
        return fatherBranch;
    }

    

    /**
     * @return the motherBranch
     */
    public Set<Relative> getMotherBranch() {
        return motherBranch;
    }

    

    /**
     * @return the siblings
     */
    public Set<Relative> getSiblings() {
        return siblings;
    }

    /**
     * @param siblings the siblings to set
     */
    public void setSiblings(Set<Relative> siblings) {
        this.siblings = siblings;
    }

    
    
    @SuppressWarnings("PMD.ExcessiveMethodLength")
    private void organizeTree(Person self) {
        Relative proband = new Relative(self, RelativeCode.SELF);

        Relative pGrandfather = new Relative();
        pGrandfather.setGender(Gender.MALE);
        
        Relative pGrandmother = new Relative();
        pGrandmother.setGender(Gender.FEMALE);

        Relative mGrandfather = new Relative();
        mGrandfather.setGender(Gender.MALE);
        
        Relative mGrandmother = new Relative();
        mGrandmother.setGender(Gender.FEMALE);
        
        List<Relative> fatherSiblings = new ArrayList<Relative>();
        List<Relative> motherSiblings = new ArrayList<Relative>();
        List<Relative> mySiblings = new ArrayList<Relative>();
        List<Relative> relatives = self.getRelatives();
        
        for (Relative rel : relatives) {
            switch (rel.getCodeEnum()) {
            case MAUNT:
            case MUNCLE:
                motherSiblings.add(rel);
                break;
            case PAUNT:
            case PUNCLE:
                fatherSiblings.add(rel);
                break;
            case MCOUSN:
            case PCOUSN:
                if (rel.getMother() != null) {
                    addParentChild(rel, rel.getMother());
                } else {
                    addParentChild(rel, rel.getFather());
                }
                break;
            case GRNDAU:
            case GRNSON:
            case NEPHEW:
            case NIECE:
                if (rel.getMother() != null) {
                    addParentChild(rel, rel.getMother());
                } else {
                    addParentChild(rel, rel.getFather());
                }                
                break;
            case DAU:
            case SON:
                addParentChild(rel, proband);
                break;
            case PGRFTH:
                pGrandfather = rel;
                break;
            case PGRMTH:
                pGrandmother = rel;
                break;
            case MGRFTH:
                mGrandfather = rel;
                break;
            case MGRMTH:
                mGrandmother = rel;
                break;
            case NBRO:
            case NSIS:
            case HBRO:
            case HSIS:
                mySiblings.add(rel);
                break;
            case NMTH:
            case NFTH:
            case SELF:
                break;
            default:
                throw new IllegalStateException("A specifier was encountered as relative code");    
            }
        } 
        motherBranch = organizeBranch(mGrandfather, mGrandmother, motherSiblings);
        fatherBranch = organizeBranch(pGrandfather, pGrandmother, fatherSiblings);
        siblings = organizeSiblings(mySiblings);
        self.setDescendants(organizeMyDescendants(proband));        
        
    }

    private void addParentChild(Relative child, Relative parent) {
        parents.put(child, parent);
        children.put(parent, child);
    }

    private MultiValueMap createMultiMap() {
        return MultiValueMap.decorate(new HashMap<Object, Object>(), HashSet.class); // NOPMD
    }
    
    private Set<Relative> getChildren(Relative relative) {
        return getRelatives(children, relative);
    }
    
    @SuppressWarnings("unchecked")
    private Set<Relative> getRelatives(MultiValueMap relMap, Relative rel) {
        Set<Relative> coll = (Set<Relative>) relMap.getCollection(rel);
        if (coll == null) {
            coll = new HashSet<Relative>();
        }
        return coll;
    }

    
    /**
     * @param topMale the grandfather
     * @param topFemale the grandmother
     * @param siblings the children of these tops
     * @return
     */
    private Set<Relative> organizeBranch(Relative topMale, Relative topFemale, List<Relative> familySiblings) {
        Set<Relative> branch = new ListOrderedSet();
        branch.add(topMale);
        branch.add(topFemale);
        for (Relative rel : familySiblings) {
            branch.add(rel);
            // grab any children and add them to the family below the parent (this person)
            for (Relative kid : getChildren(rel)) {
                branch.add(kid);
                // grab children's children: this would be nieces and nephews or grandparents in nuclear family only
                for (Relative gKid : getChildren(kid)) {
                    branch.add(gKid);
                }
            }
        }
        return branch;
    }

    /**
     * @param siblings the proband's siblings
     * @return
     */
    private Set<Relative> organizeSiblings(List<Relative> familySiblings) {
        Set<Relative> sibs = new ListOrderedSet();
        for (Relative rel : familySiblings) {
            sibs.add(rel);
            // grab any children and add them to the family below the parent (this person)
            for (Relative kid : getChildren(rel)) {
                sibs.add(kid);
                // grab children's children: this would be nieces and nephews or grandparents in nuclear family only
                for (Relative gKid : getChildren(kid)) {
                    sibs.add(gKid);
                }
            }
        }
        return sibs;
    }
    
    /**
     * @param rel the proband
     * @return
     */
    private Set<Relative> organizeMyDescendants(Relative rel) {
        Set<Relative> family = new ListOrderedSet();
        for (Relative kid : getChildren(rel)) {
            family.add(kid);
            // grab children's children
            for (Relative gKid : getChildren(kid)) {
                family.add(gKid);
            }
        }
        return family;
    }
    
}
