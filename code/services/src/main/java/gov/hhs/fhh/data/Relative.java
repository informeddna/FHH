/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data;

import gov.hhs.fhh.data.util.FormatUtils;
import gov.hhs.fhh.model.mfhp.LivingStatus;
import gov.hhs.fhh.model.mfhp.castor.RelationshipHolderNode;
import gov.hhs.fhh.model.mfhp.castor.RelativeCodeNode;

import java.util.Locale;
import java.util.UUID;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.builder.ToStringBuilder;

import com.fiveamsolutions.hl7.model.age.AgeRangeEnum;
import com.fiveamsolutions.hl7.model.age.DataEstimatedAgeNode;
import com.fiveamsolutions.hl7.model.mfhp.TwinStatus;

/**
 * @author bpickeral
 * 
 */
public class Relative extends Person {
    private static final long serialVersionUID = 1L;
    private static final boolean TRUE = true;
    private RelativeCode code;
    private String livingStatus;
    private Disease causeOfDeath;
    private AgeRangeEnum ageAtDeath;
    private String birthTime;
    private AgeRangeEnum estimatedAgeRange;
    // Used by castor when importing, mother and father may not exist at the time we get the
    // Ids, need to set Mother and father link after importing all relatives
    private UUID motherId;
    private UUID fatherId;

    /**
     * Default constructor.
     */
    public Relative() {
        // default constructor
        super();
    }

    /**
     * Copy constructor.
     * 
     * @param r the Relative object to copy from.
     */
    public Relative(Relative r) {
        super(r);
        this.code = r.code;
        this.livingStatus = r.livingStatus;
        this.causeOfDeath = r.causeOfDeath;
        this.ageAtDeath = r.ageAtDeath;
        this.birthTime = r.birthTime;
        this.motherId = r.motherId;
        this.fatherId = r.fatherId;
        this.estimatedAgeRange = r.getEstimatedAgeRange();
    }

    /**
     * Copy constructor for parent.
     * 
     * @param p the Parent object to copy from.
     */
    public Relative(Person p) {
        super(p);
        this.code = RelativeCode.SELF;
    }

    /**
     * Copy constructor for parent.
     * 
     * @param p the Parent object to copy from.
     * @param r the RelativeCode to copy from.
     */
    @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
    public Relative(Person p, RelativeCode r) {
        super(p);
        code = r;
        if (p instanceof Relative) {
            this.livingStatus = ((Relative) p).getLivingStatus();
            this.causeOfDeath = ((Relative) p).getCauseOfDeath();
            this.ageAtDeath = ((Relative) p).getAgeAtDeath();
            this.birthTime = ((Relative) p).getBirthTime();
            this.motherId = ((Relative) p).getMotherId();
            this.fatherId = ((Relative) p).getFatherId();
        } 
        
        if (p.getDateOfBirth() != null) {
             this.birthTime = FormatUtils.format(p.getDateOfBirth());
        }
    }

    /**
     * Copy constructor for parent, used by reindex - so mother and father id are not copied.
     * 
     * @param p the Parent object to copy from.
     * @param r the RelativeCode to copy from.
     * @param reindex boolean indicates whether this is being used for a reindex
     */
    @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
    public Relative(Person p, RelativeCode r, boolean reindex) {
        super(p);
        code = r;
        if (p instanceof Relative && reindex) {
            this.livingStatus = ((Relative) p).getLivingStatus();
            this.causeOfDeath = ((Relative) p).getCauseOfDeath();
            this.ageAtDeath = ((Relative) p).getAgeAtDeath();
            this.birthTime = ((Relative) p).getBirthTime();
        }
        
        if (p.getDateOfBirth() != null) {
            this.birthTime = FormatUtils.format(p.getDateOfBirth());
       }
    }

    /**
     * @return the code
     * @deprecated use getCodeEnum()
     */
    public String getCode() {
        return (code != null) ? code.name() : null;
    }

    /**
     * @param code the code to set
     * @deprecated use setCodeEnum(...)
     */
    public void setCode(String code) {
        setRelativeCode(code);
    }
    
    private void setRelativeCode(String value) {
        if (value == null) {
            this.code = null;
        } else {
            try {
                this.code = RelativeCode.valueOf(value.toUpperCase(Locale.ENGLISH));
            } catch (IllegalArgumentException e) {
                this.code = null;
            }
        }
    }
    
    /**
     * @return the code enum
     */
    public RelativeCode getCodeEnum() {
        return code;
    }
    
    /**
     * @param rc the RelativeCode value
     */
    public void setCodeEnum(RelativeCode rc) {
        this.code = (rc != null) ? rc : null;
    }

    /**
     * @return the living status enum
     */
    public LivingStatus getLivingStatusEnum() {
        return LivingStatus.getByValue(livingStatus);
    }

    /**
     * This method is used only by Castor. Since the relative xml node is different from the person node and seperate
     * from the code node, we need a way to create a relationshipHolder node while keeping the code node outside of
     * relationshipHolder.
     * 
     * @return RelationshipHolderNode
     */
    public RelationshipHolderNode getRelationshipHolderNode() {
        RelationshipHolderNode node = new RelationshipHolderNode(this);
        // Add Cause of death to Clinical Observations
        if (getCauseOfDeath() != null) {
            ClinicalObservation causeOfDeathObs = new ClinicalObservation();
            causeOfDeathObs.setDisease(getCauseOfDeath());
            causeOfDeathObs.setCauseOfDeath(TRUE);
            node.getObservations().add(causeOfDeathObs);
        }
        // Set the parent node containing the id of the parent
        setProbandParent(node);
        setMother(node);
        setFather(node);
        node.setUuid(getUuid());

        return node;
    }

    private void setMother(RelationshipHolderNode node) {
        if (getMother() != null) {
            node.getParentNodes().add(createParentNode(getMother().getUuid(), RelativeCode.NMTH));
        }
    }

    private void setFather(RelationshipHolderNode node) {
        if (getFather() != null) {
            node.getParentNodes().add(createParentNode(getFather().getUuid(), RelativeCode.NFTH));
        }
    }

    private Relative createParentNode(UUID id, RelativeCode relativeCode) {
        Relative parentNode = new Relative();
        parentNode.setUuid(id);
        parentNode.setCodeEnum(relativeCode);
        return parentNode;
    }

    private void setProbandParent(RelationshipHolderNode node) {
        if (this.isChildOfProband()) {
            if (getMotherId() != null) {
                node.getParentNodes().add(createParentNode(getMotherId(), RelativeCode.NMTH));
            }
            if (getFatherId() != null) {
                node.getParentNodes().add(createParentNode(getMotherId(), RelativeCode.NFTH));
            }
        }
    }

    /**
     * This method is used only by Castor to set the RelationshipHolderNode.
     * 
     * @param node the RelativeCodeNode containing the code value
     */
    public void setRelationshipHolderNode(RelationshipHolderNode node) {
        // Get cause of death from Clinical Observations
        for (ClinicalObservation obs : node.getObservations()) {
            if (obs.isCauseOfDeath()) {
                setCauseOfDeath(obs.getDisease());
            } else {
                getObservations().add(obs);
            }
        }

        setUuid(node.getUuid());
        setName(node.getName());
        setDateOfBirth(node.getDateOfBirth());
        setGender(node.getGender());
        setEthnicities(node.getEthnicities());
        setRaces(node.getRaces());
        setAgeAtDeath(node.getAgeAtDeath());
        setLivingStatus(node.getLivingStatus());
        setBirthTime(node.getBirthTime());
        setAdopted(node.isAdopted());
        setTwinStatus(node.getTwinStatus());
        setWeight(node.getWeight());
        setHeight(node.getHeight());
        setParentIds(node);
        setEstimatedAgeRange(node.getEstimatedAgeRange());

        if (getBirthTime() != null || getEstimatedAgeRange() != null) {
            setLivingStatus(LivingStatus.YES.toString());
        }
    }

    /**
     * Sets the mother or father id using the parent stored in the RelationshipHolderNode.
     * 
     * @param node RelationshipHolderNode containing parent's ID
     */
    private void setParentIds(RelationshipHolderNode node) {
        for (Relative currParent : node.getParentNodes()) {
            if (RelativeCode.NMTH.toString().equals(currParent.getCode())) {
                setMotherId(currParent.getUuid());
            } else {
                setFatherId(currParent.getUuid());
            }
        }
    }

    /**
     * Returns boolean indicating if person can be removed from the family tree.
     * 
     * @return true if person is removable, otherwise false
     */
    public boolean isRemovable() {
        boolean isRemovable = true;
        switch (getCodeEnum()) {
        case PGRMTH:
        case PGRFTH:
        case MGRMTH:
        case MGRFTH:
        case NMTH:
        case NFTH:
            isRemovable = false;
            break;
        default:
        }
        return isRemovable;
    }

    /**
     * Returns boolean indicating if person is deceased.
     * 
     * @return true if person is deceased, otherwise false
     */
    public boolean isDeceased() {
        boolean isDeceased = false;
        if (livingStatus != null && livingStatus.equals(LivingStatus.NO.toString())) {
            isDeceased = true;
        }
        return isDeceased;
    }

    /**
     * Used by Castor to generate the deceased indicator node if the relative is deceased. Note: isDeceased should be
     * used outside of Castor as this function returns null in the case that the relative is alive.
     * 
     * @return true string if person is deceased, otherwise null
     */
    public String getDeceasedIndicator() {
        if (isDeceased()) {
            return TRUE_STRING;
        } else if (getLivingStatus() != null && getLivingStatus().equals(LivingStatus.UNKNOWN.toString())) {
            return getLivingStatus();
        }
        return null;
    }

    /**
     * Used by Castor to set the living status of a relative.
     * 
     * @param indicator string representing if the relative is deceased
     */
    public void setDeceasedIndicator(String indicator) {
        if (indicator.equals(TRUE_STRING)) {
            setLivingStatus(LivingStatus.NO.toString());
        } else if (indicator.equals(LivingStatus.UNKNOWN.toString())) {
            setLivingStatus(LivingStatus.UNKNOWN.toString());
        }
    }

    /**
     * @return the DataEstimatedAgeNode
     */
    public DataEstimatedAgeNode getDataEstimatedAgeNode() {
        return getEstimatedAgeRange() != null ? getEstimatedAgeRange()
                .getAsDataEstimatedAgeNode() : null;
    }

    /**
     * Sets the ageRange based on the dataEstimatedAgeNode passed in.
     * 
     * @param dataEstimatedAgeNode the dataEstimatedAgeNode to get the lowValue from.
     */
    public void setDataEstimatedAgeNode(DataEstimatedAgeNode dataEstimatedAgeNode) {
        setEstimatedAgeRange(AgeRangeEnum.fromDataEstimatedAgeNode(dataEstimatedAgeNode));
    }
    
    /**
     * Returns if the form has been completed for the Relative. Unfortunately, if the user saves without
     * making any modification, we will have no way of telling that the user has completed the form.
     * @return boolean indicating that form has been completed
     */
    public boolean isCompletedForm() {
        if (isUnmatchedCondition()) {
            return false;
        }
        return relativeModified();
    }
    
    private boolean relativeModified() {
        if (!StringUtils.isEmpty(getName())
                || !StringUtils.isEmpty(getLivingStatus())
                || racesOrEthnicitiesEntered()
                || twinOrAdoptedEntered()
                || !getObservations().isEmpty()) {
            return true;
        }
        return false;
    }
    
    private boolean racesOrEthnicitiesEntered() {
        return !getRaces().isEmpty() || !getEthnicities().isEmpty();
    }
    
    private boolean twinOrAdoptedEntered() {
        return !TwinStatus.NO.equals(getTwinStatus()) || isAdopted();
    }

    /**
     * This method is used only by Castor to represent a Relative Code Node.
     * 
     * @return the RelativeCodenode.
     */
    public RelativeCodeNode getRelativeCodeNode() {
        return new RelativeCodeNode(getCode());
    }

    /**
     * This method is used only by Castor to set the relative code.
     * 
     * @param node the RelativeCodeNode containing the code value
     */
    public void setRelativeCodeNode(RelativeCodeNode node) {
        setCode(node.getCode());
    }

    /**
     * @return the livingStatus
     */
    public String getLivingStatus() {
        return livingStatus;
    }

    /**
     * @param livingStatus the livingStatus to set
     */
    public void setLivingStatus(String livingStatus) {
        this.livingStatus = livingStatus;
    }

    /**
     * @return the causeOfDeath
     */
    public Disease getCauseOfDeath() {
        return causeOfDeath;
    }

    /**
     * @param causeOfDeath the causeOfDeath to set
     */
    public void setCauseOfDeath(Disease causeOfDeath) {
        this.causeOfDeath = causeOfDeath;
    }

    /**
     * @return the birthTime
     */
    public String getBirthTime() {
        return birthTime;
    }

    /**
     * @param birthTime the birthTime to set
     */
    public void setBirthTime(String birthTime) {
        this.birthTime = birthTime;
    }

    /**
     * @return the motherId
     */
    public UUID getMotherId() {
        return motherId;
    }

    /**
     * @param motherId the motherId to set
     */
    public void setMotherId(UUID motherId) {
        this.motherId = motherId;
    }

    /**
     * @return the fatherId
     */
    public UUID getFatherId() {
        return fatherId;
    }

    /**
     * @param fatherId the fatherId to set
     */
    public void setFatherId(UUID fatherId) {
        this.fatherId = fatherId;
    }

    /**
     * {@inheritDoc}
     */
    public String toString() {
        return new ToStringBuilder(this).append(getName()).append(getCode()).toString();
    }

    /**
     * @return the ageAtDeath
     */
    public AgeRangeEnum getAgeAtDeath() {
        return ageAtDeath;
    }

    /**
     * @param ageAtDeath the ageAtDeath to set
     */
    public void setAgeAtDeath(AgeRangeEnum ageAtDeath) {
        this.ageAtDeath = ageAtDeath;
    }

    /**
     * @return the estimatedAgeRange
     */
    public AgeRangeEnum getEstimatedAgeRange() {
        return estimatedAgeRange;
    }

    /**
     * @param estimatedAgeRange the estimatedAgeRange to set
     */
    public void setEstimatedAgeRange(AgeRangeEnum estimatedAgeRange) {
        this.estimatedAgeRange = estimatedAgeRange;
    }

    /**
     * @return boolean specifying if Relative is a child of the proband.
     */
    public boolean isChildOfProband() {
        return (RelativeCode.DAU.equals(this.getCodeEnum()) 
                || RelativeCode.SON.equals(this.getCodeEnum()));
    }
}
