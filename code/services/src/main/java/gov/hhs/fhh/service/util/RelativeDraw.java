/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.service.util;

import gov.hhs.fhh.data.ClinicalObservation;
import gov.hhs.fhh.data.Disease;
import gov.hhs.fhh.data.Person;
import gov.hhs.fhh.data.Relative;
import gov.hhs.fhh.data.RelativeCode;
import gov.hhs.fhh.data.util.DiseaseUtils;
import gov.hhs.fhh.model.mfhp.LivingStatus;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.awt.geom.Ellipse2D;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.map.MultiValueMap;
import org.apache.commons.collections.set.ListOrderedSet;

import com.fiveamsolutions.hl7.model.mfhp.Gender;

/**
 * @author lpower
 * @author hniedner
 */
// CHECKSTYLE:OFF legacy code slightly updated
@SuppressWarnings({"PMD.ExcessiveClassLength","PMD.CyclomaticComplexity","PMD.TooManyMethods",
    "PMD.LooseCoupling","PMD.ExcessiveMethodLength","PMD.UnusedPrivateField","PMD.NPathComplexity",
    "PMD.AvoidReassigningParameters","PMD.CollapsibleIfStatements","PMD.UnusedLocalVariable",
    "PMD.NcssMethodCount","PMD.ImmutableField","PMD.TooManyFields",
    "PMD.SignatureDeclareThrowsException","PMD.AvoidThrowingRawExceptionTypes","PMD.SystemPrintln"})
public class RelativeDraw extends Relative {
    private static final long serialVersionUID = 1L;

    /**
     * Yellow Color for highlighting proband.
     */
    public static final Color YELLOW_HIGHLIGHT = new Color(234, 237, 99);
    
   /**
    * Red Color for highlighting.
    */
    public static final Color RED_HIGHLIGHT = new Color(209, 35, 35);
    /**
     * Blue Color for highlighted diseases.
     */
    public static final Color BLUE_HIGHLIGHT = new Color(140, 211, 247);

    private int xLoc;
    private int yLoc;
    private boolean hasSpouse = false;

    private RelativeDraw spouse;

    private boolean autoDrawChildren = true;

    private Disease highlightDisease;
    private boolean highlighted;
    private boolean showNames = true;

    public final static int PERSONSIZE = 30;
    public final static int SPOUSEDISTANCE = 120;
    public final static int CHILDRENDISTANCE = 60;
    public final static int CHILDRENBARLENGTH = 30;
    public final static int SIBLINGSPACING = 70;

    
    private final MultiValueMap parents = createMultiMap(); // person->their parents
    private final MultiValueMap children = createMultiMap(); // person->their children
    private final MultiValueMap siblings = createMultiMap(); // person->their siblings
    private List<RelativeDraw> kids = new ArrayList<RelativeDraw>();
    private TextGetter textGetter;
    
    /**
     * Copy constructor.
     * 
     * @param r the Relative object to copy from.
     */
    public RelativeDraw(final Relative r, TextGetter textGetter) {
        super(r);
        this.textGetter = textGetter;
    }

    /**
     * Copy constructor.
     * 
     * @param r the Relative object to copy from.
     */
    public RelativeDraw(final RelativeDraw r, TextGetter textGetter) {
        super(r);
        this.textGetter = textGetter;
        xLoc = r.getXLoc();
        yLoc = r.getYLoc();
        hasSpouse = r.isHasSpouse();
        spouse = r.getSpouse();
        autoDrawChildren = r.isAutoDrawChildren();
        autoDrawChildren = r.isAutoDrawChildren();
        highlightDisease = r.getHighlightDisease();
    }

    /**
     * @return the xLoc
     */
    public int getXLoc() {
        return xLoc;
    }

    /**
     * @param loc the xLoc to set
     */
    public void setXLoc(final int loc) {
        xLoc = loc;
    }

    /**
     * @return the yLoc
     */
    public int getYLoc() {
        return yLoc;
    }

    /**
     * @param loc the yLoc to set
     */
    public void setYLoc(final int loc) {
        yLoc = loc;
    }

    /**
     * @return the hasSpouse
     */
    public boolean isHasSpouse() {
        return hasSpouse;
    }

    /**
     * @param hasSpouse the hasSpouse to set
     */
    public void setHasSpouse(final boolean hasSpouse) {
        this.hasSpouse = hasSpouse;
    }

    /**
     * @return the spouse
     */
    public RelativeDraw getSpouse() {
        return spouse;
    }

    /**
     * @param spouse the spouse to set
     */
    public void setSpouse(final RelativeDraw spouse) {
        this.spouse = spouse;
        setHasSpouse(true);
    }

    /**
     * @return the autoDrawChildren
     */
    public boolean isAutoDrawChildren() {
        return autoDrawChildren;
    }

    /**
     * @param autoDrawChildren the autoDrawChildren to set
     */
    public void setAutoDrawChildren(final boolean autoDrawChildren) {
        this.autoDrawChildren = autoDrawChildren;
    }

    /**
     * @return the highlightDisease
     */
    public Disease getHighlightDisease() {
        return highlightDisease;
    }

    /**
     * @param highlightDisease the highlightDisease to set
     */
    public void setHighlightDisease(final Disease highlightDisease) {
        this.highlightDisease = highlightDisease;
    }

    /**
     * @return the showNames
     */
    public boolean isShowNames() {
        return showNames;
    }

    /**
     * @param showNames the showNames to set
     */
    public void setShowNames(final boolean showNames) {
        this.showNames = showNames;
    }

    /**
     * @return the kids
     */
    public List<RelativeDraw> getKids() {
        return kids;
    }

    /**
     * @param kids the kids to set
     */
    public void setKids(final List<RelativeDraw> kids) {
        this.kids = kids;
    }

    /**
     * Gets the width of this person's children (icons). Calls getChildrenWidth(RelativeDraw, boolean) with this
     * person's autoDraw setting.
     * 
     * @param p RelativeDraw whose children should be drawn
     * @return int width of this person' children
     */
    public int getChildrenWidth(final RelativeDraw p) {
        return getChildrenWidth(p, p.isAutoDrawChildren());
    }

    /**
     * Gets the width of this person's children (icons).
     * 
     * @param p RelativeDraw whose children should be drawn
     * @param includeChildren boolean indicates whether children should be included
     */
    private int getChildrenWidth(final RelativeDraw p, final boolean includeChildren) {
        int ret = 0;
        if (p.getKids().size() == 0 || !includeChildren) {
            return PERSONSIZE + SIBLINGSPACING;
        }
        for (final RelativeDraw rel: p.getKids()) {
            ret += getChildrenWidth(rel);
        }
        return ret;
    }

    /**
     * Draws this person - calls to draw from outside the method typically call for a grandfather or father.
     * 
     * @param g the 2D image
     * @param x the x position of the person on the image
     * @param y the y position of the person on the image
     * @param r RelativeDraw whose children should be drawn
     * @param showNames boolean indicates whether names should be shown in the image
     * @param abbreviationMap - abbreviations are global across all diseases of all family members, so this has to be passed around.
     */
    @SuppressWarnings("PMD.ExcessiveParameterList")
    public void draw(final java.awt.Graphics2D g, final int x, final int y, final RelativeDraw r, final boolean showNames, final Disease highlight, 
            Map<Disease, String> abbreviationMap) {
        //insert hints to make a nice image
        final RenderingHints rh = g.getRenderingHints ();
        rh.put (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHints (rh);
        //set coords
        r.setXLoc(x);
        r.setYLoc(y);
        //unknown gender
        if (r.getGender() == null) {
            final boolean highlighted = writeDiseaseCheckHighlight(g, r, highlight, abbreviationMap);
            if (highlighted) {
                drawDiamond(g, x, y, BLUE_HIGHLIGHT);
            } else if (r.getCode().equals(RelativeCode.SELF.toString())) {
                drawDiamond(g, x, y, YELLOW_HIGHLIGHT);
            } else {
                drawDiamond(g, x, y, null);
            }
            if (!r.isAutoDrawChildren()) {
                return;
            }
            drawChildrenOfFemaleOrNongendered(g, r, showNames, highlight, abbreviationMap);
        } else {
            if (r.getGender().equals(Gender.MALE)) {
                final boolean highlighted = writeDiseaseCheckHighlight(g, r, highlight, abbreviationMap);
                if (highlighted) {
                    g.setColor(BLUE_HIGHLIGHT);
                    g.fillRect(x, y, PERSONSIZE, PERSONSIZE);
                    g.setColor(Color.BLACK);
                } else if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    g.setColor(YELLOW_HIGHLIGHT);
                    g.fillRect(x, y, PERSONSIZE, PERSONSIZE);
                    g.setColor(Color.BLACK);
                }
                g.drawRect(x, y, PERSONSIZE, PERSONSIZE);
                
                if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    ShapeUtil.drawRightDirectedArrow(g, x + 7 * PERSONSIZE / 8, y + PERSONSIZE / 2);
                }
                
                if (spouse != null && spouse != this || r.getSpouse() != null) {
                    // exception for mother of the father - she shows up twice if drawn here
                    if (!spouse.getCodeEnum().equals(RelativeCode.NMTH)) {
                        spouse.draw(g, x + SPOUSEDISTANCE, y, spouse, showNames, highlight, abbreviationMap);
                    }
                } else {
                    r.spouse = this;
                    r.setHasSpouse(false);
                }
                if (r.getKids().size() > 0 && r.isAutoDrawChildren()) {
                    r.drawChildren(g, showNames, r, highlight, abbreviationMap);
                }
            } else { // This is a female
                final boolean highlighted = writeDiseaseCheckHighlight(g, r, highlight, abbreviationMap);
                if (highlighted) {
                    drawFemale(g, x, y, BLUE_HIGHLIGHT);
                } else if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    drawFemale(g, x, y, YELLOW_HIGHLIGHT);
                } else {
                    drawFemale(g, x, y, null);
                }
                if (r.getCode().equals(RelativeCode.SELF.toString())) {
                    ShapeUtil.drawLeftDirectedArrow(g, x + PERSONSIZE / 8, y + PERSONSIZE / 2);
                }
                if (!r.isAutoDrawChildren()) {
                    return;
                }
                drawChildrenOfFemaleOrNongendered(g, r, showNames, highlight, abbreviationMap);
            }
        }

        if (r.getLivingStatus() != null) {
            if (r.getLivingStatus().equals(LivingStatus.NO.toString())) {
                g.setColor(Color.RED);
                g.drawLine(x + PERSONSIZE, y, x, y + PERSONSIZE);
                g.setColor(Color.BLACK);
            }
        }
        g.getFontMetrics();
        final int codeLeftSpace = 10;
        final int codeRightSpace = 20;
        final RelativeCode rc = RelativeCode.getByValue(r.getCode());
        String relativeDisplay = getText(rc);
        // remove maternal and paternal for length
        if (relativeDisplay.startsWith("Paternal ") || relativeDisplay.startsWith("Maternal ")) {
            relativeDisplay = relativeDisplay.substring(9,relativeDisplay.length());
        }
        if (relativeDisplay.endsWith("por parte de madre") || relativeDisplay.endsWith("por parte de padre")) {
            relativeDisplay = relativeDisplay.substring(0, relativeDisplay.indexOf("por") - 1);
        }
        if (r.getCode().equals(RelativeCode.SELF.toString())) {
            g.setPaint(RED_HIGHLIGHT);
        }
        g.drawString("[" + relativeDisplay + "]", x - codeLeftSpace, y + PERSONSIZE + codeRightSpace);
        if (r.getCode().equals(RelativeCode.SELF.toString())) {
            g.setColor(Color.BLACK);
        }
        if (showNames) {
            String displayName = r.getName();
            if (displayName != null) {
                if (displayName.length() > 15) {
                    displayName = displayName.subSequence(0, 12) + "...";
                }
            } else {
                displayName = " ";
            }
            g.drawString(displayName, x - codeLeftSpace, y + PERSONSIZE + codeRightSpace
                    + g.getFontMetrics().getHeight());
        }
    }
    
    //female family member
    private void drawFemale(final Graphics2D g, final int x, final int y, final Color highlight) {
        final Ellipse2D circle = makeCircle(x, y);
        if (highlight != null) {
            g.setColor(highlight);
            g.fill(circle);
        }
        g.setColor(Color.BLACK);
        g.draw(circle);
    }

    //unknown gender family member
    private void drawDiamond(final Graphics2D g, final int x, final int y, final Color highlight) {
        final Polygon diamond = makeDiamond(x, y);
        if (highlight != null) {
            g.setColor(highlight);
            g.fillPolygon(diamond);
        }
        g.setColor(Color.BLACK);
        g.draw(diamond);
    }

    protected String getText(final RelativeCode rc) {
        return textGetter.getText(rc.getResourceKey());
    }

    /**
     * Calls to draw children of female or non-gendered relatives (aunts or siblings).
     * 
     * @param g 2D image
     * @param r RelativeDraw whose children should be drawn
     * @param showNames
     */
    private void drawChildrenOfFemaleOrNongendered(final java.awt.Graphics2D g, final RelativeDraw r, final boolean showNames, final Disease highlight, 
            Map<Disease, String> abbreviationMap) {
        // female aunt or sibling (no spouse) - draw children
        if (r.getKids().size() > 0) {
            r.spouse = this;
            r.setHasSpouse(false);
            r.drawChildren(g, showNames, r, highlight, abbreviationMap);
        }
    }

    /**
     * Make diamond for folks whose gender is unknown.
     * 
     * @param x starting point of this image
     * @param y starting point of this image
     */
    private Polygon makeDiamond(final int x, final int y) {
        final Polygon diamond = new Polygon();
        // top
        diamond.addPoint(x + PERSONSIZE / 2, y);
        // right
        diamond.addPoint(x + PERSONSIZE, y + PERSONSIZE / 2);
        // bottom
        diamond.addPoint(x + PERSONSIZE / 2, y + PERSONSIZE);
        // left
        diamond.addPoint(x, y + PERSONSIZE / 2);
        return diamond;
    }

    /**
     * Make circle for the females.
     * 
     * @param x starting point of this image
     * @param y starting point of this image
     */
    private Ellipse2D.Double makeCircle(final int x, final int y) {
        final Ellipse2D.Double circle;
        //same width and height = radius
        final double radius = PERSONSIZE;
        circle = new Ellipse2D.Double(x, y, radius, radius);
        return circle;
    }
    
    /**
     * Method draws the children of this relative.
     * 
     * @param g 2D image to be drawn
     * @param showNames boolean indicates whether names will be printed on the chart
     * @param r RelaiveDraw whose children should be drawn
     */
    public void drawChildren(final java.awt.Graphics2D g, final boolean showNames, final RelativeDraw r, final Disease highlight, 
            Map<Disease, String> abbreviationMap) {
        // convert all descendants to RelativeDraws - shouldn't that have been done already?
        final List<RelativeDraw> l = new ArrayList<RelativeDraw>(r.getKids());
        r.setAutoDrawChildren(true);
       
        java.awt.geom.Line2D.Double connectorLine;
        // connect the parents
        if (!r.isHasSpouse() || spouse == this) {
            spouse = this;
            r.setHasSpouse(false);
            connectorLine = new java.awt.geom.Line2D.Double((r.getXLoc() + r.getXLoc() + PERSONSIZE) / 2, r.getYLoc()
                    + PERSONSIZE, (r.getXLoc() + r.getXLoc() + PERSONSIZE) / 2, r.getYLoc() + PERSONSIZE / 2
                    + CHILDRENDISTANCE);
        } else {
            final RelativeDraw spouse = r.getSpouse();
            g.drawLine(r.getXLoc() + PERSONSIZE, r.getYLoc() + PERSONSIZE / 2, spouse.getXLoc(), spouse.getYLoc()
                    + PERSONSIZE / 2);
            connectorLine = new java.awt.geom.Line2D.Double((r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r
                    .getYLoc()
                    + PERSONSIZE / 2, (r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r.getYLoc()
                    + PERSONSIZE / 2 + CHILDRENDISTANCE);
        }
        g.draw(connectorLine);

        // no kids - here by mistake
        if (l.isEmpty()) {
            return;
        }
        // one child
        if (l.size() == 1) {
            // line to connect child to parent line
            g.drawLine((r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r.getYLoc() + PERSONSIZE / 2
                    + CHILDRENDISTANCE, (r.getXLoc() + r.getSpouse().getXLoc() + PERSONSIZE) / 2, r.getYLoc()
                    + PERSONSIZE / 2 + CHILDRENDISTANCE + CHILDRENBARLENGTH);
            // get and draw the kid
            final RelativeDraw kid = l.get(0);
            final int kidX = (r.getXLoc() + r.getSpouse().getXLoc()) / 2;
            final int kidY = r.getYLoc() + PERSONSIZE / 2 + CHILDRENDISTANCE + CHILDRENBARLENGTH;
            kid.draw(g, kidX, kidY, kid, showNames, highlight, abbreviationMap);
        } else {
            // more than one child
            int lineLength = r.getChildrenWidth(r) - PERSONSIZE - SIBLINGSPACING;
            // get the last child and see if that child has children - this sets the size of this child grouping
            if (l.get((l.size() - 1)).getKids().size() > 1) {
                if (l.get(0).getKids().size() > 1) {
                    lineLength -= r.getChildrenWidth(l.get(0)) / 2 - PERSONSIZE / 2 - SIBLINGSPACING
                            / 2;
                }
                lineLength -= r.getChildrenWidth(l.get(l.size() - 1)) / 2 - PERSONSIZE / 2
                        - SIBLINGSPACING / 2;
            }
            double lastChild = 0;
            for (int lcv = 0; lcv < l.size(); lcv++) {
                double childX = 0;
                if (lcv == 0) {
                    childX = connectorLine.getX1() - lineLength / 2;
                } else {
                    final int lastWidth = r.getChildrenWidth(l.get(lcv - 1));
                    childX = lastChild + lastWidth / 2 + r.getChildrenWidth(l.get(lcv)) / 2;
                }
                final java.awt.geom.Line2D.Double childBar = new java.awt.geom.Line2D.Double(childX, connectorLine.getY2(),
                        childX, connectorLine.getY2() + CHILDRENBARLENGTH);
                lastChild = childX;
                // draw the bar that connects all of the children
                g.draw(childBar);
                // now draw this child
                final RelativeDraw drawChild = l.get(lcv);
                final int kidX = (int) (childBar.getX1() - PERSONSIZE / 2);
                final int kidY = (int) childBar.getY2();
                drawChild.draw(g, kidX, kidY, drawChild, showNames, highlight, abbreviationMap);
            }
            final int lineStart = l.get(0).getXLoc() + PERSONSIZE / 2;
            final int lineEnd = l.get(l.size() - 1).getXLoc() + PERSONSIZE / 2;
            final java.awt.geom.Line2D.Double crossLine = new java.awt.geom.Line2D.Double(lineStart, connectorLine
                    .getY2(), lineEnd, connectorLine.getY2());
            g.draw(crossLine);
            // draw the line between any twins - this could stand refactoring
            final List<RelativeDraw> theTwins = new ArrayList<RelativeDraw>();
            for (final RelativeDraw potentialTwin : r.getKids()) {
                if (potentialTwin.isTwin()) {
                    theTwins.add(potentialTwin);
                }
            }
            if (theTwins.size() >= 1) {
                drawTwinLines(g, theTwins);
            }
        }
    }

    /**
     * Find the mid-point between twin relatives.
     * 
     * @param m list of relatives who are twins
     */
    private static int findMidPoint(final List<RelativeDraw> m) {
        final RelativeDraw firstTwin = m.get(0);
        final RelativeDraw lastTwin = m.get(m.size() - 1);
        return (firstTwin.getXLoc() + lastTwin.getXLoc()) / 2 + PERSONSIZE / 2;
    }

    /**
     * Draws the triangular lines for twin relationships.
     * 
     * @param g the 2D image
     * @param m list of relatives who are twins
     */
    public void drawTwinLines(final java.awt.Graphics2D g, final List<RelativeDraw> m) {
        final int midPoint = findMidPoint(m);
        final RelativeDraw firstTwin = m.get(0);
        final RelativeDraw lastTwin = m.get(m.size() - 1);
        for (final RelativeDraw twin : m) {
            g.drawLine(twin.getXLoc() + PERSONSIZE / 2, twin.getYLoc(), midPoint, twin.getYLoc() - CHILDRENBARLENGTH);
        }
        g.drawLine((firstTwin.getXLoc() + PERSONSIZE / 2 + midPoint) / 2, firstTwin.getYLoc() - CHILDRENBARLENGTH / 2,
                (lastTwin.getXLoc() + PERSONSIZE / 2 + midPoint) / 2, firstTwin.getYLoc() - CHILDRENBARLENGTH / 2);
    }

    

    /**
     * Organizes family and creates drawing for the proband.
     * 
     * @param self Person (proband) to be organized
     * @return byte[] to be drawn
     * @throws Exception 
     */
    public byte[] organizeFamilyTree(final Person self, Map<Disease, String> abbreviationMap) throws Exception  {
        try {

            RelativeDraw firstGen2 = null;
            RelativeDraw firstGen3 = null;
            final Set<RelativeDraw> family = new ListOrderedSet();

                // Map family = new HashMap();
                final List<Relative> maternalHalfSiblings = new ArrayList<Relative>();
                final List<Relative> paternalHalfSiblings = new ArrayList<Relative>();
                final List originalRelatives = self.getRelatives();
                final List<RelativeDraw> relatives = new ArrayList(convertToRelativeDraw(originalRelatives));
                

                final Relative proband = new Relative(self, RelativeCode.SELF);
                //RelativeDraw selfDraw = new RelativeDraw(proband);
                Relative pGrandfather = new Relative();
                Relative pGrandmother = new Relative();
                Relative mGrandfather = new Relative();
                Relative mGrandmother = new Relative();
                Relative dad = null;
                Relative mom = null;
                
                final List<Relative> fatherSiblings = new ArrayList<Relative>();
                final List<Relative> motherSiblings = new ArrayList<Relative>();
                
                boolean probandGrandkids = false;

                int cousinCount = 0; // used for determining size of drawing
                
                final List<RelativeDraw> myRels = new ArrayList<RelativeDraw>(convertToRelativeDraw(self.getRelatives()));
                // go through the relatives and slap them into the sets
                for (final Relative rel : self.getRelatives()) {
                    switch (rel.getCodeEnum()) {
                    case MAUNT:
                    case MUNCLE:
                        motherSiblings.add(rel);
                        addSiblings(self.getMother(), rel);
                        break;
                    case PAUNT:
                        fatherSiblings.add(rel);
                        addSiblings(self.getFather(), rel);
                        break;
                    case PUNCLE:
                        firstGen2 = copy(rel);
                        fatherSiblings.add(rel);
                        addSiblings(self.getFather(), rel);
                        break;
                    case MCOUSN:
                    case PCOUSN:
                        if (rel.getMother() != null) {
                            addParentChild(rel, rel.getMother());
                        } else {
                            addParentChild(rel, rel.getFather());
                        }
                        cousinCount++;
                        break;
                    case GRNDAU:
                        probandGrandkids = true;
                    case GRNSON:
                        probandGrandkids = true;
                    case NEPHEW:
                    case NIECE:
                        if (rel.getMother() != null) {
                            addParentChild(rel, rel.getMother());
                        } else {
                            addParentChild(rel, rel.getFather());
                        }                
                        break;
                    case HBRO:
                    case HSIS:
                        if (rel.getMother() != null) {
                            addParentChild(rel, rel.getMother());
                            maternalHalfSiblings.add(rel);
                        } else {
                            addParentChild(rel, rel.getFather());
                            paternalHalfSiblings.add(rel);
                        }                
                        break;
                    case DAU:
                    case SON:
                        addParentChild(rel, proband);
                        break;
                    case PGRFTH:
                        pGrandfather = rel;
                        addParentChild(self.getFather(), rel);
                        break;
                    case PGRMTH:
                        pGrandmother = rel;
                        break;
                    case MGRFTH:
                        mGrandfather = rel;
                        addParentChild(self.getMother(), rel);
                        break;
                    case MGRMTH:
                        mGrandmother = rel;
                        break;
                    case NBRO:
                        addParentChild(rel, self.getMother());
                        addParentChild(rel, self.getFather());
                        addSiblings(proband, rel);
                        break;
                    case NSIS:
                        addParentChild(rel, self.getMother());
                        addParentChild(rel, self.getFather());
                        addSiblings(proband, rel);
                        break;
                    case NFTH:
                        dad = rel;
                        addParentChild(proband, rel);
                        break;
                    case NMTH:
                        mom = rel;
                        break;
                        default:
                        throw new IllegalStateException("A specifier was encountered as relative code");    
                    }
                }

                if (firstGen2 == null) {
                    firstGen2 = copy(dad);
                }
                    
                final RelativeDraw father = copy(dad);
                final RelativeDraw selfDraw = copy(proband);
                boolean haveKidsOrNiecesNephews = false;
                boolean haveGrandkids = false;
                // organize my own kids and grandkids) as descendant of dad
                for (final Relative myKid: getChildren(proband)) {
                    for (final Relative myGrandkid: getChildren(myKid)) {
                        myKid.getDescendants().add(myGrandkid);
                        haveGrandkids = true;
                    }
                    haveKidsOrNiecesNephews = true;
                    final RelativeDraw kid = copy(myKid);
                    kid.setKids(convertToRelativeDraw(myKid.getDescendants()));
                    selfDraw.getKids().add(kid);
                }
                // organize my siblings (and their kids) as descendants of dad
                // brothers on left, then proband, then sisters on right
                // set first and last siblings to account for half siblings
                RelativeDraw firstSibling = null;
                RelativeDraw lastSibling = null;
                final ArrayList<RelativeDraw> holdingSisters = new ArrayList<RelativeDraw>();
                for (final Relative r: getSiblings(proband)) {
                    for (final Relative nieceNephew: getChildren(r)) {
                        r.getDescendants().add(nieceNephew);
                        haveKidsOrNiecesNephews = true;
                    }
                    final RelativeDraw rel = copy(r);
                    rel.setKids(convertToRelativeDraw(r.getDescendants()));
                    if (r.getCodeEnum().equals(RelativeCode.NBRO)) {
                        if (firstSibling == null) {
                            firstSibling = rel;
                        }
                        father.getKids().add(rel);
                    }
                    else {
                        holdingSisters.add(rel);
                    }
                }
                // add self
                father.getKids().add(selfDraw);
                lastSibling = selfDraw;
                // add sisters
                father.getKids().addAll(holdingSisters);
                if (!holdingSisters.isEmpty()) {
                    lastSibling = holdingSisters.get(holdingSisters.size()-1);
                }
                if (firstSibling == null) {
                    firstSibling = selfDraw;
                }

                final RelativeDraw paternalGrandfather = copy(pGrandfather);
                // organize father's siblings as descendants of paternal grandfather
                // brother on left, then sisters, and father on far right
                // father should be last
                for (final Relative r: fatherSiblings) {
                    final RelativeDraw rel = copy(r);
                    if (!r.getCodeEnum().equals(RelativeCode.NFTH)) {
                        for (final Relative cousin: getChildren(r)) {
                            r.getDescendants().add(cousin);
                            rel.setKids(convertToRelativeDraw(r.getDescendants()));
                        }
                        paternalGrandfather.getKids().add(rel);
                    }
                }
                final RelativeDraw mother = copy(mom);
                father.setSpouse(mother);
                // set father to not automatically draw children - we'll do this manually
                father.setAutoDrawChildren(false);
                paternalGrandfather.getKids().add(father);

                // organize mother's siblings as descendants of paternal grandfather
                // mother should be first
                final RelativeDraw maternalGrandfather = copy(mGrandfather);
                maternalGrandfather.getKids().add(mother);
                for (final Relative r: motherSiblings) {
                    if (!r.getCodeEnum().equals(RelativeCode.NMTH)) {
                        final RelativeDraw rel = copy(r);
                        for (final Relative cousin: getChildren(r)) {
                            r.getDescendants().add(cousin);
                            rel.setKids(convertToRelativeDraw(r.getDescendants()));
                        }
                        maternalGrandfather.getKids().add(rel);
                    }
                }

                final RelativeDraw paternalGrandmother = copy(pGrandmother);
                final RelativeDraw maternalGrandmother = copy(mGrandmother);
                paternalGrandfather.setSpouse(paternalGrandmother);
                maternalGrandfather.setSpouse(maternalGrandmother);
                

                final int halfSiblingSpace = Math.max(paternalHalfSiblings.size(), maternalHalfSiblings.size()) * 2
                        * (PERSONSIZE + SIBLINGSPACING);
                
                


            // ---------------- Start Drawing -------------------------------------
            final int widthSpacer = 20;
            final int width = paternalGrandfather.getChildrenWidth(paternalGrandfather)
                    + maternalGrandfather.getChildrenWidth(maternalGrandfather) + father.getChildrenWidth(father, true)
                    + PERSONSIZE + SIBLINGSPACING + SPOUSEDISTANCE + halfSiblingSpace + widthSpacer;

            int floatUnderSpace = 0;
            if (cousinCount == 0) {
                floatUnderSpace = Math.min(paternalGrandfather.getChildrenWidth(paternalGrandfather), maternalGrandfather
                        .getChildrenWidth(maternalGrandfather));
            }

            int height = 300;
            if (haveKidsOrNiecesNephews) {
                height = 400;
            }
            if (haveGrandkids) {
                height = 550;
            }
            final int imageWidth = Math.max(width, 700);
            //int imageSize = width;

            final java.awt.image.BufferedImage image = new java.awt.image.BufferedImage(imageWidth, height,
                    java.awt.image.BufferedImage.TYPE_INT_RGB);
            final java.awt.Graphics2D g = (java.awt.Graphics2D) image.getGraphics();

            g.setColor(java.awt.Color.WHITE);
            g.fillRect(0, 0, imageWidth, height);
            g.setColor(java.awt.Color.BLACK);

            final int startSpacing = 50;
            int startPos = paternalGrandfather.getChildrenWidth(paternalGrandfather) / 2 + 10 - SPOUSEDISTANCE / 2;
            if (startPos < startSpacing) {
                startPos = startSpacing;
            }
            // if there are no brothers or paternal uncles and self has lots of kids we need to
            // move the drawing over.
            int firstGen2Shift = 0;
            int firstGen3Shift = 0;
            if (firstGen2.getKids().size() > 4) {
                firstGen2Shift = (firstGen2.getKids().size() - 2) * (PERSONSIZE + SIBLINGSPACING) / 2;
            }
            if (firstGen2.getKids().size() > 0) {
                final ListOrderedSet l = (ListOrderedSet) firstGen2.getKids();
                firstGen3 = copy((RelativeDraw) l.get(0));
                if (firstGen3.getKids().size() > 4) {
                    firstGen3Shift = (firstGen3.getKids().size() - 2) * (PERSONSIZE + SIBLINGSPACING) / 2;
                }
            }
            startPos += firstGen2Shift + firstGen3Shift;
            final int yPos = 5;

            // need to set father NOT to autodraw!!!
            // father.spouse = mother;

            paternalGrandfather.setXLoc(startPos);
            paternalGrandfather.setYLoc(yPos);
            paternalGrandfather.draw(g, startPos, yPos, paternalGrandfather, showNames, getHighlightDisease(), abbreviationMap);

            final int mg = paternalGrandfather.getXLoc()
                    + paternalGrandfather.getChildrenWidth(paternalGrandfather)
                    / 2
                    - PERSONSIZE
                    - SIBLINGSPACING
                    + paternalGrandfather.getChildrenWidth(maternalGrandfather)
                    / 2
                    + Math.max(paternalGrandfather.getChildrenWidth(father, true) + halfSiblingSpace - floatUnderSpace,
                            SPOUSEDISTANCE * 2 + PERSONSIZE);

            maternalGrandfather.setXLoc(mg);
            maternalGrandfather.setYLoc(yPos);
            maternalGrandfather.draw(g, mg, yPos, maternalGrandfather, showNames, getHighlightDisease(), abbreviationMap);
            father.drawChildren(g, showNames, father, getHighlightDisease(), abbreviationMap);

            // Draw half siblings
            for (final RelativeDraw myrel : convertToRelativeDraw(paternalHalfSiblings)) {
                if (myrel.getCode().equals(RelativeCode.HBRO.toString())
                        || myrel.getCode().equals(RelativeCode.HSIS.toString())) {
                    myrel.draw(g, firstSibling.getXLoc() - RelativeDraw.SIBLINGSPACING - RelativeDraw.PERSONSIZE,
                            firstSibling.getYLoc(), myrel, showNames, getHighlightDisease(), abbreviationMap);
                    // think need to add this to draw, but not sure - don't know how to get dad's x and y locations
                    final java.awt.geom.Line2D.Double upline = new java.awt.geom.Line2D.Double(myrel.getXLoc()
                            + RelativeDraw.PERSONSIZE / 2, myrel.getYLoc(), father.getXLoc() + RelativeDraw.PERSONSIZE / 2,
                            father.getYLoc() + RelativeDraw.PERSONSIZE);
                    g.draw(upline);
                    firstSibling = myrel;
                }
            }
            for (final RelativeDraw myrel : convertToRelativeDraw(maternalHalfSiblings)) {
                if (myrel.getCode().equals(RelativeCode.HBRO.toString())
                        || myrel.getCode().equals(RelativeCode.HSIS.toString())) {
                    myrel.draw(g, lastSibling.getXLoc() + RelativeDraw.SIBLINGSPACING + RelativeDraw.PERSONSIZE,
                            lastSibling.getYLoc(), myrel, showNames, getHighlightDisease(), abbreviationMap);
                    // think need to add this to draw, but not sure - don't know how to get dad's x and y locations
                    final java.awt.geom.Line2D.Double upline = new java.awt.geom.Line2D.Double(myrel.getXLoc()
                            + RelativeDraw.PERSONSIZE / 2, myrel.getYLoc(), mother.getXLoc() + RelativeDraw.PERSONSIZE / 2,
                            mother.getYLoc() + RelativeDraw.PERSONSIZE);
                    g.draw(upline);
                    lastSibling = myrel;
                }
            }
            final PngEncoderB encoder = new PngEncoderB(image);
            encoder.setCompressionLevel(5);
            return encoder.pngEncode();
            
        }
        finally { 
            final int x=0; 
        }
    }

    protected RelativeDraw copy(final Relative pGrandmother) {
        return new RelativeDraw(pGrandmother, textGetter);
    }


    /**
     * Method converts list of Relative objects to RelativeDraw objects. Also assigns Gender to Relatives from which
     * Gender can be inferred from the RelativeCode (ex: aunt assumes female).
     * 
     * @return List of RelativeDraw
     */
    protected List<RelativeDraw> convertToRelativeDraw(final Collection<Relative> relatives) {
        final List<RelativeDraw> r = new ArrayList<RelativeDraw>();
        for (final Relative myrel : relatives) {
//            Shouldn't be needed!
//            myrel.setUuid(UUIDFieldHandler.createUuidFromId(relatives.indexOf(myrel)));
            // assign gender in rd if we can intuit it
            if (myrel.getGender() == null
                    || !myrel.getGender().equals(Gender.FEMALE) || !myrel.getGender().equals(Gender.MALE)) {
                getImpliedGender(myrel);
            }
            final RelativeDraw rd = copy(myrel);
            r.add(rd);
        }
        return r;
    }

    
    /**
     * @param myrel
     */
    protected void getImpliedGender(final Relative myrel) {
            if (myrel instanceof Relative && myrel.getCodeEnum().getImpliedGender() != null) {
                myrel.setGender(myrel.getCodeEnum().getImpliedGender());
            }
    }

    
    private void addSiblings(final Relative sibling1, final Person sibling2) {
        siblings.put(sibling1, sibling2);
        siblings.put(sibling2, sibling1);
    }
    
    private MultiValueMap createMultiMap() {
        return MultiValueMap.decorate(new HashMap<Object, Object>(), HashSet.class); // NOPMD
    }

    private void addParentChild(final Relative child, final Relative parent) {
        parents.put(child, parent);
        children.put(parent, child);
    }
    
    @SuppressWarnings("unchecked")
    private Set<Relative> getRelatives(final MultiValueMap relMap, final Relative rel) {
        Set<Relative> coll = (Set<Relative>) relMap.getCollection(rel);
        if (coll == null) {
            coll = new HashSet<Relative>();
        }
        return coll;
    }

    @SuppressWarnings("PMD.UnusedPrivateMethod")
    private Set<Relative> getChildren(final Relative relative) {
        return getRelatives(children, relative);
    }

    private Set<Relative> getSiblings(final Relative relative) {
        return getRelatives(siblings, relative);
    }
    
    

    /**
     * Method writes the diseases that this person has.
     * 
     * @param g the 2D image
     * @param r the RelativeDraw whose diseases will be shown
     * @param highlight the Disease to be highlighted
     * @return boolean whether this person has the highlighted disease
     */
    public boolean writeDiseaseCheckHighlight(final java.awt.Graphics2D g, final RelativeDraw r, final Disease highlight, Map<Disease, String> abbreviationMap) {
        boolean highlightMe = false;
        final int textAdd = 8;
        final int textSpacing = 9;
        final int textStartSpacing = 30;
        final Font f = g.getFont();
        g.setFont(new Font("Tahoma", Font.TRUETYPE_FONT, 10));
        int textPos = r.getYLoc() + textAdd;
        final List<ClinicalObservation> diseases = r.getObservations();
        Set<Disease> diseaseObjects = new HashSet<Disease>(); 
        for (final ClinicalObservation ci : diseases) {
            if(!diseaseObjects.contains(ci.getDisease())){
                diseaseObjects.add(ci.getDisease());
            }
        }
        if (r.getGender() == null) {
            for (final ClinicalObservation ci : diseases) {
                final Disease d = ci.getDisease();
                if (DiseaseUtils.compareHighlightDisease(d, highlight)) {
                    highlightMe = true;
                }
                final String abbrev = abbreviationMap.get(d);
                g.drawString(abbrev, r.getXLoc() - textStartSpacing, textPos);
                textPos += textSpacing;
            }
        } else {
            if (r.getGender().equals(Gender.FEMALE)) {
                for (final ClinicalObservation ci : diseases) {
                    final Disease d = ci.getDisease();
                    if (DiseaseUtils.compareHighlightDisease(d, highlight)) {
                        highlightMe = true;
                    }
                    final String abbrev = abbreviationMap.get(d);
                    g.drawString(abbrev, r.getXLoc() + textAdd + PERSONSIZE, textPos);
                    textPos += textSpacing;
                }
            }
            if (r.getGender().equals(Gender.MALE)) {
                for (final ClinicalObservation ci : diseases) {
                    final Disease d = ci.getDisease();
                    if (DiseaseUtils.compareHighlightDisease(d, highlight)) {
                        highlightMe = true;
                    }
                    final String abbrev = abbreviationMap.get(d);
                    g.drawString(abbrev, r.getXLoc() - textStartSpacing, textPos);
                    textPos += textSpacing;
                }
            }
        }
        g.setFont(f);
        return highlightMe;
    }
    
    /**
     * @param relatives list of this person's relatives
     * @param relative this relative whose children we're looking for
     */
    /*
    private Relative getChildren(List<Relative> relatives, Relative potentialParent) {
        for (Relative myrel : relatives) {
            myrel.setId(Long.valueOf(relatives.indexOf(myrel)));
            Relative parent = new Relative();
            if (myrel.getFather() != null) {
                parent = myrel.getFather();
            }
            if (myrel.getMother() != null) {
                parent = myrel.getMother();
            }
            if (parent != null && parent.equals(potentialParent)) {
                RelativeDraw rd = new RelativeDraw(myrel);
                potentialParent.getDescendants().add(rd);
            }
        }
        return potentialParent;
    } */
}
// CHECKSTYLE:ON
