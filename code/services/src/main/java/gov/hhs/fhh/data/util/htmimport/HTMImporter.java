/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the "software") and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.data.util.htmimport;

import gov.hhs.fhh.data.AgeRangeEnumUtils;
import gov.hhs.fhh.data.ClinicalObservation;
import gov.hhs.fhh.data.Disease;
import gov.hhs.fhh.data.Person;
import gov.hhs.fhh.data.Relative;
import gov.hhs.fhh.data.RelativeCode;
import gov.hhs.fhh.data.util.DiseaseUtils;
import gov.hhs.fhh.data.util.FhhDataUtils;
import gov.hhs.fhh.data.util.FormatUtils;
import gov.hhs.fhh.htm.Builder;
import gov.hhs.fhh.htm.CobraBuilder;
import gov.hhs.fhh.htm.HiddenInput;
import gov.hhs.fhh.htm.InputNode;
import gov.hhs.fhh.model.mfhp.LivingStatus;
import gov.hhs.fhh.model.mfhp.castor.HTMNode;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import com.fiveamsolutions.hl7.model.age.AgeRangeEnum;
import com.fiveamsolutions.hl7.model.mfhp.Height;
import com.fiveamsolutions.hl7.model.mfhp.HeightUnit;
import com.fiveamsolutions.hl7.model.mfhp.TwinStatus;
import com.fiveamsolutions.hl7.model.mfhp.Weight;
import com.fiveamsolutions.hl7.model.mfhp.WeightUnit;

/**
 * @author bpickeral
 *
 */
@SuppressWarnings({"PMD.TooManyMethods", "PMD.ExcessiveClassLength" })
public class HTMImporter {

    /**
     * The number of fixed relatives always in the legacy import. Includes parents + grandparents.
     */
    public static final int NUM_FIXED_RELATIVES = 7;
    
    /**
     * The value of the parent node for Relatives that don't need to specify parents.
     */
    public static final String CALCULATED = "calculated";
    
    private static final String YES = "Yes";
    private static final String ONSET = "Onset";
    private static final String NAME_ATTR = "Name";
    private static final String LIVING_ATTR = "StillLiving";
    private static final String GENDER_ATTR = "Gender";
    private static final String ADD_DISEASES_ATTR = "AdditionalDiseases";
    private static final String PARENT_ATTR = "Parent";
    private static final String AGE_AT_DEATH_ATTR = "AgeAtDeath";
    private static final String TWIN_ATTR = "IsTwin";
    private static final String WEIGHT_ATTR = "Weight";
    private static final String HEIGHT_ATTR = "Height";
    private static final String AGE_ATTR = "Age";
    private static final String COD_ATTR = "CauseOfDeath";
    private static final String HEART_DISEASE_ATTR = "Coronary";
    private static final String HEART_DISEASE_ONSET = "Coronary" + ONSET;
    private static final String STROKE_ATTR = "Stroke";
    private static final String STROKE_ONSET = "Stroke" + ONSET;
    private static final String DIABETES_ATTR = "Diabetes";
    private static final String DIABETES_ONSET = "Diabetes" + ONSET;
    private static final String COLON_CANCER_ATTR = "ColonCancer";
    private static final String COLON_CANCER_ONSET = "ColonCancer" + ONSET;
    private static final String BREAST_CANCER_ATTR = "BreastCancer";
    private static final String BREAST_CANCER_ONSET = "BreastCancer" + ONSET;
    private static final String OVARIAN_CANCER_ATTR = "OvarianCancer";
    private static final String OVARIAN_CANCER_ONSET = "OvarianCancer" + ONSET;
    private static final String FAMILY_ADD_DISEASE_STR = "additionalDisease";
    private static final String FAMILY_ADD_PER_RELATIVE = "Addit";
    
    private static final Logger LOG = Logger.getLogger(HTMImporter.class);
    
    /**
     * Stores information from the HTMNode into the Person object.
     * @param htmFileContents The legacy import file in String format.
     * @return Person with extracted information
     */
    public Person build(String htmFileContents) {
        Map<String, InputNode> extractInputNodes = this.extractInputNodes(htmFileContents);
        return this.extractHtmNode(extractInputNodes);
    }
    
    /**
     * Generates a List of <code>InputNode</code> objects from an .htm file.
     * @param htmFileContents The legacy import file in String format.
     * @return List of InputNodes
     */
    private Map<String, InputNode> extractInputNodes(String htmFileContents) {
        InputStream is = new ByteArrayInputStream(htmFileContents.getBytes());
        Builder<InputNode> builder = new CobraBuilder<InputNode>();
        List<InputNode> result = new ArrayList<InputNode>();
        
        builder.build(is, result, new HiddenInput());
        Map<String, InputNode> inputNodeMap = new HashMap<String, InputNode>();
        for (InputNode currNode : result) {
            inputNodeMap.put(currNode.getName(), currNode);
        }
        return inputNodeMap;
    }
    
    /**
     * Stores information from the HTMNode into the Person object.
     * 
     * @param inputNodes Map of the attribute of the input Node to InputNode objects from htm file containing 
     *  attributes
     * @return Person with extracted information
     */
    protected Person extractHtmNode(Map<String, InputNode> inputNodes) {
        Person p = new Person();
        // Create a map of all possible relatives to an HTMNode that will hold all of the InputNode objects for that
        // relative
        Map<String, HTMNode> relativeMap = createRelativeMap(inputNodes);
        
        // Obtain the list of family additional conditions
        Map<String, Disease> familyAddCondtitions = 
            processFamilyAddConditions(inputNodes.get(FAMILY_ADD_DISEASE_STR));
        inputNodes.remove(FAMILY_ADD_DISEASE_STR);
        
        // Store each set of input nodes associated with a single relative into an HTMNode
        seperateInputNodes(relativeMap, inputNodes);
        
        processPersonAttributes(p, relativeMap.get(HTMRelationship.SELF.getRelationship()), familyAddCondtitions);
        
        // Process Fixed relatives (parents, grandparents)
        for (HTMRelationship currRelationship : HTMRelationship.values()) {
            if (!currRelationship.isVariableRelative() && !currRelationship.equals(HTMRelationship.SELF)) {
                processRelativeAttributes(p, relativeMap.get(currRelationship.getRelationship()), familyAddCondtitions);
            }
        }
        processVariableRelativeNodes(p, relativeMap, familyAddCondtitions);
        return p;
    }

    
    
    /**
     * Creates a map of htm relative type strings to an HTMNode object that will hold input nodes
     *  corresponding to the relative.
     * @param inputNodes inputNodes from htm file
     * @return map of htm relative type strings to HTMNode objects
     */
    protected Map<String, HTMNode> createRelativeMap(Map<String, InputNode> inputNodes) {
        Map<String, HTMNode> relativeMap = new HashMap<String, HTMNode>();
        
        for (HTMRelationship currRelationship : HTMRelationship.values()) {
            if (currRelationship.isVariableRelative()) {
                InputNode numRelativeNode = inputNodes.get(currRelationship.getRelationship());
                int numRelatives = Integer.valueOf(numRelativeNode.getValue());
                for (int i = 0; i < numRelatives; i++) {
                    String htmName = currRelationship.getRelationship() + (i + 1);
                    HTMNode htmNode = new HTMNode(convertLegacyCodeToHTMRelationship(
                            currRelationship.getRelationship()), i + 1, htmName);
                    relativeMap.put(htmName, htmNode);
                } 
                inputNodes.remove(numRelativeNode);
            } else {
                HTMNode htmNode = new HTMNode(convertLegacyCodeToHTMRelationship(
                        currRelationship.getRelationship()), null, currRelationship.getRelationship());
                relativeMap.put(currRelationship.getRelationship(), htmNode);
            }
        }
        return relativeMap;
    }
    /**
     * Separates inputNodes into the corresponding HTMNode holding all of the input nodes for that relative.
     * @param relativeMap map of relatives in which input nodes will reside
     * @param inputNodes map of input nodes to sort
     */
    protected void seperateInputNodes(Map<String, HTMNode> relativeMap, 
            Map<String, InputNode> inputNodes) {
        
        for (InputNode currNode : inputNodes.values()) {
            storeInputNode(relativeMap, currNode);
        }
    }
    
    /**
     * @param relativeMap map of relatives to reference
     * @param inputNode the node to process
     */
    protected void storeInputNode(Map<String, HTMNode> relativeMap, 
            InputNode inputNode) {
        NumberFormat nf = NumberFormat.getInstance();
        try {
            HTMRelationship relativeType = extractHTMRelationship(inputNode.getName());
            if (relativeType != null) {
                String numStr = "";
                int numIndex = relativeType.getRelationship().length();
                if (relativeType.isVariableRelative()) {
                    int num = nf.parse(StringUtils.substring(inputNode.getName(), numIndex)).intValue();
                    numStr = String.valueOf(num);
                    
                    numIndex += numStr.length();
                } 
                String htmAttribute = StringUtils.substring(inputNode.getName(), numIndex);
                
                HTMNode node = relativeMap.get(relativeType.getRelationship() + numStr);
                node.getInputNodes().put(htmAttribute, inputNode);
            }
        } catch (ParseException fe) {
            LOG.error(fe.getMessage() + ": " + fe.getStackTrace());
        }
    }
    
    /**
     * Processes an <code>HTMNode</code> object associated with a Person and stores the
     *  information in the <code>Person</code> object.
     * @param p the <code>Person</code> object
     * @param node the <code>HTMNode</code> containing information about Self.
     * @param familyAddConditions the list of family conditions
     */
    protected void processPersonAttributes(Person p, HTMNode node, Map<String, Disease> familyAddConditions) {
        Map<String, InputNode> inputNodes = node.getInputNodes();
        processSharedAttributes(p, node, familyAddConditions, inputNodes);
        
        setHTMWeight(p, inputNodes.get(WEIGHT_ATTR));
        setHTMHeight(p, inputNodes.get(HEIGHT_ATTR));
        setHTMDateOfBirth(p, inputNodes.get(AGE_ATTR));
    }
    
    /**
     * @param p person to populate
     * @param node purpose unknown
     * @param familyAddConditions purpose unknown
     * @param inputNodes purpose unknown
     */
    protected void processSharedAttributes(Person p, HTMNode node, Map<String, Disease> familyAddConditions, 
            Map<String, InputNode> inputNodes) {
        //InputNode currInputNode;
        setHTMName(p, inputNodes.get(NAME_ATTR));
        // We always assume Self is living, ignore self living status
        setHTMGender(p, inputNodes.get(GENDER_ATTR));
        // TO Do: handle additional diseases
        setHTMTwinStatus(p, inputNodes.get(TWIN_ATTR));
        
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(HEART_DISEASE_ATTR), 
                DiseaseUtils.HEART_DISEASE_CODE), inputNodes.get(HEART_DISEASE_ONSET));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(STROKE_ATTR), 
                DiseaseUtils.STROKE_CODE), inputNodes.get(STROKE_ONSET));
        setAgeRangeForObservation(createDiabetesObservation(p, inputNodes.get(DIABETES_ATTR), 
                DiseaseUtils.DIABETES_CODE), inputNodes.get(DIABETES_ONSET));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(COLON_CANCER_ATTR), 
                DiseaseUtils.COLON_CANCER_CODE), inputNodes.get(COLON_CANCER_ONSET));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(BREAST_CANCER_ATTR), 
                DiseaseUtils.BREAST_CANCER_CODE), inputNodes.get(BREAST_CANCER_ONSET));
        setAgeRangeForObservation(createClinicalObservation(p, inputNodes.get(OVARIAN_CANCER_ATTR), 
                DiseaseUtils.OVARIAN_CANCER_CODE), inputNodes.get(OVARIAN_CANCER_ONSET));
        // The legacy input handles additional diseases in 2 different places
        // Handle the additional diseases entered on each individual relative screen
        setHTMAdditionalDiseases(p, inputNodes.get(ADD_DISEASES_ATTR));
        // Handle the additional diseases that are tracked for the entire family tree 
        setHTMFamilyAdditionalDiseases(p, node, familyAddConditions);
    }
    
    /**
     * Processes an <code>HTMNode</code> object associated with a relative and stores the
     *  information in the <code>Person</code> object.
     * @param p the <code>Person</code> object
     * @param node the <code>HTMNode</code> containing information about Self.
     * @param familyAddConditions the list of family conditions
     * @return relative Relative added to the tree
     */
    protected Relative processRelativeAttributes(Person p, HTMNode node, Map<String, 
            Disease> familyAddConditions) {
        Map<String, InputNode> inputNodes = node.getInputNodes();
        Relative relative = createRelative(p, node);
        p.getRelatives().add(relative);
        
        processSharedAttributes(relative, node, familyAddConditions, inputNodes);
        
        setHTMLivingStatus(relative, inputNodes.get(LIVING_ATTR));
        setHtmAgeAtDeath(relative, inputNodes.get(AGE_AT_DEATH_ATTR));
        setHtmCauseOfDeath(relative, inputNodes.get(COD_ATTR));

        node.setRelative(relative);
        return relative;
    }
    
    /**
     * Creates the relative and sets the RelativeCode.
     */
    private Relative createRelative(Person proband, HTMNode node) {
        Relative relative = new Relative();
        relative.setCodeEnum(node.getHtmRelationship().getRelativeCode());
        // Set proband's mother if node is mother node
        if (RelativeCode.NMTH.equals(node.getHtmRelationship().getRelativeCode())) {  
            proband.setMother(relative);
        // Set proband's father if node is father node
        } else if (RelativeCode.NFTH.equals(node.getHtmRelationship().getRelativeCode())) {
            proband.setFather(relative);
        }
        return relative;
    }
    
    private void setHTMName(Person p, InputNode node) {
        if (!StringUtils.isEmpty(node.getValue())) {
            p.setName(FormatUtils.performXSSFilter(node.getValue()));
        }
    }
    
    private void setHTMLivingStatus(Relative r, InputNode node) {
        if (!StringUtils.isEmpty(node.getValue())) {
            r.setLivingStatus(LivingStatus.fromHTMInputNode(node).toString());
        }
    }
    
    private void setHtmAgeAtDeath(Relative r, InputNode node) {
        // Legacy system did not have error checking non int value was entered in user input
        if (nodeValueExists(node) && StringUtils.isNumeric(node.getValue())) {
            r.setAgeAtDeath(AgeRangeEnumUtils.fromHTMInputNode(node));
        } 
    }
    
    private void setHtmCauseOfDeath(Relative r, InputNode node) {
        if (nodeValueExists(node)) {
            r.setCauseOfDeath(DiseaseUtils.findOrCreateNewDisease(FormatUtils.performXSSFilter(node.getValue())));
        } 
    }
    
    
    
    private void setHTMAdditionalDiseases(Person p, InputNode node) {
        if (nodeValueExists(node)) {
            String[] diseaseAgePairs = StringUtils.split(node.getValue(), ',');
            for (String currPair : diseaseAgePairs) {
                addObservationForAdditionalDisease(p, currPair);
            }
        }
    }
    
    private void setHTMFamilyAdditionalDiseases(Person p, HTMNode htmNode, 
            Map<String, Disease> familyAddConditions) {
        Map<String, InputNode> inputNodes = htmNode.getInputNodes();
        
        for (String currKey : familyAddConditions.keySet()) {
            InputNode inputNode = inputNodes.get(currKey);
            setAgeRangeForObservation(createHTMFamilyAdditionalObservation(p, inputNode, 
                    familyAddConditions.get(currKey)), inputNodes.get(currKey + ONSET));
        }
    }
    
    private ClinicalObservation createHTMFamilyAdditionalObservation(Person p, InputNode inputNode, 
            Disease condition) {
        ClinicalObservation obs = null;
        if (isBooleanInputTrue(inputNode)) {
            obs = new ClinicalObservation();
            obs.setDisease(condition);
            DiseaseUtils.setMatchedOrUnmatched(p, obs);
            p.getObservations().add(obs);
        }
        return obs;
    }
    
    private void addObservationForAdditionalDisease(Person p, String diseaseAgePair) {
        ClinicalObservation obs = new ClinicalObservation();
        int separatorIndex = diseaseAgePair.lastIndexOf('/');
        String disease = null;
        AgeRangeEnum ageAtDiagnosis = null;
        // The legacy tool used separator characters ',' and '/', but allowed users to add additional characters of 
        // the same type and had no error checking. If there is ever a pair without a separator, extract the condition
        // and set age range to unknown.
        if (separatorIndex == -1) {
            disease = diseaseAgePair;
        } else {
            disease = StringUtils.substring(diseaseAgePair, 0, separatorIndex);
            ageAtDiagnosis = AgeRangeEnum.getByHtmValue(StringUtils.substring(diseaseAgePair, separatorIndex + 1));
        }
        if (ageAtDiagnosis == null) {
            ageAtDiagnosis = AgeRangeEnum.UNKNOWN;
        }
        
        obs.setDisease(DiseaseUtils.findOrCreateNewDisease(FormatUtils.performXSSFilter(disease)));
        obs.setAgeRange(ageAtDiagnosis);
        DiseaseUtils.setMatchedOrUnmatched(p, obs);
        p.getObservations().add(obs);
    }
    
    private void setAgeRangeForObservation(ClinicalObservation observation, InputNode node) {
        if (observation != null) {
            if (StringUtils.isEmpty(node.getValue())) {
                observation.setAgeRange(AgeRangeEnum.UNKNOWN);
            } else {
                observation.setAgeRange(AgeRangeEnum.getByHtmValue(node.getValue()));
            }
        }
    }
    
    private ClinicalObservation createClinicalObservation(Person p, InputNode node, String snomedCode) {
        ClinicalObservation observation = null;
        if (isBooleanInputTrue(node)) {
            Disease d = FhhDataUtils.getCodeToDiseaseMap().get(snomedCode);
            observation = new ClinicalObservation();
            observation.setDisease(d);
            p.getObservations().add(observation);
        }
        return observation;
    }
    
    private ClinicalObservation createDiabetesObservation(Person p, InputNode node, String snomedCode) {
        ClinicalObservation obs = createClinicalObservation(p, node, snomedCode);
        if (obs != null) {
            obs.setUnmatchedCondition(true);
            p.setUnmatchedCondition(true);
        }
        return obs;
    }
    
    private void setHTMTwinStatus(Person p, InputNode node) {
        if (!StringUtils.isEmpty(node.getValue())) {
            // The Legacy FHH only supported identical twin status
            if (isBooleanInputTrue(node)) {
                p.setTwinStatus(TwinStatus.IDENTICAL);
            } else {
                p.setTwinStatus(TwinStatus.NO);
            }
        }
    }
    
    private void setHTMGender(Person p, InputNode node) {
        p.setGender(node.toGenderNode());
    }
    
    private boolean isBooleanInputTrue(InputNode node) {
        return node.getValue().equals(YES) ? true : false;
    }
    
    /**
     * Processes the second set of relative nodes that can range from 0 or more relatives of one type.
     *  This includes all relatives other than parents and grandparents.
     * @param p <code>Person</code> to store relatives
     * @param relativeMap <code>HTMNode</code> map containing InputNode objects to process.
     * @param familyAddConditions the map of node names to family conditions
     */
    protected void processVariableRelativeNodes(Person p, Map<String, HTMNode> relativeMap, 
            Map<String, Disease> familyAddConditions) {
        List<HTMNode> remainingNodes = new ArrayList<HTMNode>();
        for (String currKey : relativeMap.keySet()) {
            processVariableRelativeNode(p, familyAddConditions, relativeMap.get(currKey), remainingNodes);
        }
        for (HTMNode childNode : remainingNodes) {
            processChildNode(processRelativeAttributes(p, childNode, familyAddConditions), p, childNode, relativeMap);
        }
    }
    
    private void processVariableRelativeNode(Person p,
            Map<String, Disease> familyAddConditions, HTMNode htmNode, List<HTMNode> remainingNodes) {
        if (htmNode.isVariableRelative()) {
            // Process Nodes where parent is not required first, add any children to remainingNodes to be processed
            // after parents have been created.
            if (htmNode.getHtmRelationship().isParentRequired()) {
                remainingNodes.add(htmNode);
            } else {
                processRelativeAttributes(p, htmNode, familyAddConditions);
            }
        } 
    }
    
    /**
     * Processes an <code>HTMNode</code> object associated with a variable relative and stores the
     *  information in the <code>Relative</code> object and links the relative to parent relatives
     *  for cousins and half siblings. A variable relative is a relative in which there can be 0 or 
     *  more of (any relative other than parents, grandparents).
     * @param relative the <code>Relative</code> object
     * @param root the root Person in the tree
     * @param node the <code>HTMNode</code> containing information about Self.
     * @param relativeMap <code>HTMNode</code> map containing InputNode objects to process.
     */
    protected void processChildNode(Relative relative, Person root, HTMNode node, 
            Map<String, HTMNode> relativeMap) {
        String parentValue = node.getInputNodes().get(PARENT_ATTR).getValue();
        // Drop the relative from the tree if no parent is specified
        if (StringUtils.isBlank(parentValue)) {
            root.getRelatives().remove(relative);
            root.getHtmImportDroppedRelatives().add(relative);
        } else if (!StringUtils.equals(CALCULATED, parentValue)) {
            linkParentToChild(relative, parentValue, relativeMap);
        }
    }
    
    private void linkParentToChild(Relative relative, String parentValue, 
            Map<String, HTMNode> relativeMap) {
        RelativeCode parentCode = convertLegacyCodeToHTMRelationship(parentValue).getRelativeCode();
        Relative parent = relativeMap.get(parentValue).getRelative();
        if (parentCode.isMale()) {
            relative.setFather(parent);
        } else {
            relative.setMother(parent);
        }
        // If code is cousin, set code as paternal cousin or maternal cousin
        if (RelativeCode.COUSN.equals(relative.getCodeEnum())) {
            if (parentCode.isMothersSibling()) {
                relative.setCodeEnum(RelativeCode.MCOUSN);
            } else {
                relative.setCodeEnum(RelativeCode.PCOUSN);
            }
        }
    }
    
    private void setHTMWeight(Person p, InputNode node) {
        if (nodeValueExists(node)) {
            p.setWeight(new Weight(Integer.valueOf(node.getValue()), WeightUnit.US));
        }
    }
    
    private void setHTMHeight(Person p, InputNode node) {
        if (nodeValueExists(node)) {
            p.setHeight(new Height(Integer.valueOf(node.getValue()), HeightUnit.US));
        }
    }
    
    private void setHTMDateOfBirth(Person p, InputNode node) {
        if (nodeValueExists(node)) {
            p.setDateOfBirth((FormatUtils.convertAgeToDOB(Integer.valueOf(node.getValue()))));
        }
    }
    
    /**
     * Returns true if node is not null and contains a value.
     * @param node InputNode
     * @return true if node is not null and contains a value, otherwise false
     */
    protected boolean nodeValueExists(InputNode node) {
        if (node != null && !StringUtils.isBlank(node.getValue())) {
            return true;
        }
        return false;
    }
    
    /**
     * Generates a list of additional conditions for the family from the last input node from the legacy import.
     * @param node <code>InputNode</code> to process
     * @return list of diseases
     */
    private Map<String, Disease> processFamilyAddConditions(InputNode node) {
        Map<String, Disease> conditions = new HashMap<String, Disease>();
        String[] diseases = StringUtils.split(node.getValue(), ',');
        int i = 1;
        for (String currDisease : diseases) {
            conditions.put(FAMILY_ADD_PER_RELATIVE + i, 
                    DiseaseUtils.findOrCreateNewDisease(FormatUtils.performXSSFilter(currDisease)));
            i++;
        }
        return conditions;
    }

    /**
     * Converts a legacy relative code (htmValue) to an FHH code.
     * @param relative String to convert
     * @return HTMRelationship
     */
    public HTMRelationship convertLegacyCodeToHTMRelationship(String relative) {
        return extractHTMRelationship(relative);
    }

    /**
     * Extracts the HTMRelationship from the input node name.
     * @param inputNodeName the name of the InputNode from legacy import
     * @return HTMRelationship corresponding to the node
     */
    protected HTMRelationship extractHTMRelationship(String inputNodeName) {
        for (HTMRelationship currCode : HTMRelationship.values()) {
            if (inputNodeName.startsWith(currCode.getRelationship())) {
                return currCode;
            }
        }
        return null;
    }

}
