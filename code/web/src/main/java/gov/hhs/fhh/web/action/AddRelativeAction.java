/**
 * 
 * Family Health History Portal 
 * END USER AGREEMENT
 * 
 * The U.S. Department of Health & Human Services (“HHS”) hereby irrevocably 
 * grants to the user a non-exclusive, royalty-free right to use, display, 
 * reproduce, and distribute this Family Health History portal software 
 * (the “software”) and prepare, use, display, reproduce and distribute 
 * derivative works thereof for any commercial or non-commercial purpose by any 
 * party, subject only to the following limitations and disclaimers, which 
 * are hereby acknowledged by the user.  
 * 
 * User agrees that it will not degrade the standards-based format of the software 
 * by materially altering the program architecture or data structure in a way 
 * that would render the data generated by the altered software incompatible 
 * with the original software. The intention of this clause is to ensure the 
 * long-term interoperability of family history information gathered by different 
 * versions of the tool.
 * 
 * User agrees that this END USER AGREEMENT will be provided to any party to 
 * whom user distributes the software, and that it will apply to the distributee.
 * 
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS 
 * trademarks without permission from HHS, and will not imply endorsement of 
 * its product by HHS or the Surgeon General.
 * 
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED, 
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, 
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT, 
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 * 
 */
package gov.hhs.fhh.web.action;

import gov.hhs.fhh.data.Disease;
import gov.hhs.fhh.data.Person;
import gov.hhs.fhh.data.Relative;
import gov.hhs.fhh.data.RelativeCode;
import gov.hhs.fhh.data.util.DiseaseUtils;
import gov.hhs.fhh.data.util.FormatUtils;
import gov.hhs.fhh.data.util.LabelValue;
import gov.hhs.fhh.web.FhhRegistry;
import gov.hhs.fhh.web.util.FhhHttpSessionUtil;
import gov.hhs.fhh.web.util.FhhUtils;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;

import org.ajaxtags.xml.AjaxXmlBuilder;
import org.apache.commons.lang.StringUtils;
import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.Preparable;
import com.opensymphony.xwork2.validator.annotations.RequiredFieldValidator;
import com.opensymphony.xwork2.validator.annotations.Validations;

/**
 * @author bpickeral
 *
 */
@SuppressWarnings({ "PMD.CyclomaticComplexity", "PMD.ExcessiveClassLength", "PMD.TooManyFields", 
    "PMD.TooManyMethods" })
public class AddRelativeAction extends AddPersonAction implements Preparable {
    private static final long serialVersionUID = 1927846653L;
    private static final boolean TRUE = true;
    private static final String REQUIRED_FIELD = "struts.validator.requiredString";

    private Relative relative;

    private List<Disease> codSubTypes = new ArrayList<Disease>();
    private List<RelativeCode> relationshipSpecifiers = new ArrayList<RelativeCode>();
    private List<String> existingRelativeCodes = new ArrayList<String>();
    private List<Relative> parents = new ArrayList<Relative>();
    private Disease causeOfDeath;
    private Disease selectedCODSubType;
    private String relativeAge;
    private boolean codSubTypesExist;
    private String relationshipSpecifier;
    private String selectedCodeValue;
    private String currentCODValue;
    private Integer selectedParentIndex;
    private String relativeId;
    private String otherCOD;
    private String lastAddedCOD;

    /**
     * {@inheritDoc}
     */
    public void prepare() {
        Person rootPerson = FhhHttpSessionUtil.getRootPerson();
        if (rootPerson != null) {
            setPerson(rootPerson);
            if (getRelativeId() != null) {
                setRelative(getPerson().getRelatives().get(Integer.valueOf(getRelativeId())));
                setSelectedCode(getRelative().getCode());
                setupDiseasesAndAges(getRelative());
                setupBirthYear();
                setupCauseOfDeath();
                setupLegacyWarningMessages(getRelative());
            } else {
                setRelative(new Relative());
            }
            setupGender();
            setSelectionVariables();
        }
    }

    /**
     * Sets the Birth year or Date of birth to be displayed in the jsp for a Relative that is being edited.
     */
    public void setupBirthYear() {
        if (relative.getBirthTime() != null) {
            if (FhhUtils.checkDateFormat(relative.getBirthTime())) {
                setDateOfBirthString(relative.getBirthTime());
            } else {
                Calendar calendar = Calendar.getInstance();
                Integer birthYear = Integer.valueOf(relative.getBirthTime());
                setRelativeAge(String.valueOf(calendar.get(Calendar.YEAR) - birthYear));
            }
        }
    }

    /**
     * Sets the Cause of death to be displayed in the jsp for a Relative that is being edited.
     */
    public void setupCauseOfDeath() {
        // The COD is added to the Disease List, store the ID of the row in the Disease List table of the last 
        // added COD.  This is used to remove the COD when a new COD is entered.
        setCodSubTypesExist(false);
        if (relative.getCauseOfDeath() != null) {
            if (relative.getCauseOfDeath().getParent() == null) {
                setCauseOfDeath(relative.getCauseOfDeath());
                if (relative.getCauseOfDeath().getId() == DiseaseUtils.OTHER_DISEASE_ID) {
                    setOtherCOD(relative.getCauseOfDeath().getOriginalText());
                }
                setLastAddedCOD(DiseaseUtils.generateDiseaaseTableId(relative.getCauseOfDeath(), 
                        relative.getAgeAtDeath()));
            } else {
                setCauseOfDeath(relative.getCauseOfDeath().getParent());
                setSelectedCODSubType(relative.getCauseOfDeath());
                setCodSubTypesExist(TRUE);
                setLastAddedCOD(DiseaseUtils.generateDiseaaseTableId(getSelectedCODSubType(), 
                        relative.getAgeAtDeath()));
            }
        }
    }
    
    /**
     * Set the implied gender of the Relative when adding a new relative.
     */
    private void setupGender() {
        if (!StringUtils.isEmpty(getSelectedCode())
                && relative.getGender() == null 
                && RelativeCode.getByValue(getSelectedCode()).getImpliedGender() != null) {
            relative.setGender(RelativeCode.getByValue(getSelectedCode()).getImpliedGender());
        }
    }

    /**
     * {@inheritDoc}
     */
    public void setSelectionVariables() {
        // Set up variables for Edit/Add Relative
        if (getSelectedCode() != null) {
            if (causeOfDeath != null) {
                setCodSubTypes(FhhRegistry.getPersonService().getDiseaseSubTypes(causeOfDeath.getId()));
            }
            super.setSelectionVariables();
            // Set up variables for select relative
        } else {
            setExistingRelativeCodes(FhhUtils.getExistingCodes(getPerson().getRelatives()));
        }

    }

    /**
     * Method is called after selecting a relative to call the add person page.
     *
     * @return path String
     */
    @Validations(
        requiredFields = { 
            @RequiredFieldValidator(fieldName = "selectedCode",
                key = REQUIRED_FIELD, message = "")
            })
    public String addPerson() {
        RelativeCode code = RelativeCode.getByValue(getSelectedCode());
        //Check for errors, return if errors are present
        checkSelectRelativeErrors(code);
        if (!getFieldErrors().isEmpty()) {
            return INPUT;
        } 
        // Handle Maternal/Paternal codes
        if (code.isSpecifier()) {
            // Cousin specifies parent - set Maternal/Paternal
            if (RelativeCode.COUSN.toString().equals(code.toString())) {
                Relative parent = getPerson().getRelatives().get(selectedParentIndex);
                if (RelativeCode.MAUNT.toString().equals(parent.getCode())
                        || RelativeCode.MUNCLE.toString().equals(parent.getCode())) {
                    setSelectedCode(code.getMaternalCode());
                } else {
                    setSelectedCode(code.getPaternalCode());
                }
            // All other codes specify Maternal/Paternal
            } else if (RelativeCode.NMTH.toString().equals(relationshipSpecifier)) {
                setSelectedCode(code.getMaternalCode());
            } else {
                setSelectedCode(code.getPaternalCode());
            }
        }
        
        return SUCCESS;
    }
    /**
     * Method adds field errors for the addPerson Method called when selecting a relative to add
     * to the family tree.
     * @param code of the relative being added
     */
    private void checkSelectRelativeErrors(RelativeCode code) {
        // Add errors if Parent was not specified for codes that require specification.
        if (!FhhUtils.getParents(code.toString(), getPerson().getRelatives()).isEmpty()
                && selectedParentIndex == null) {
            addFieldError("selectedParentIndex", getText("selectedParentIndex") + " " + getText(REQUIRED_FIELD));
        }
        // Add error if no Maternal/Paternal relationship was specified
        if (code.isSpecifier() && !RelativeCode.COUSN.toString().equals(code.toString())
                && relationshipSpecifier == null) {
            addFieldError("relationshipSpecifier", getText("relationshipSpecifier") + " " + getText(REQUIRED_FIELD));
        }
    }

    /**
     * Action to load the relative selection div.
     * 
     * @return the result
     */
    public String retrieveRelationshipSpecifiers() {
        if (RelativeCode.getByValue(selectedCodeValue).isSpecifier()) {
            relationshipSpecifiers = FhhUtils.getRelationshipSpecifiers(selectedCodeValue);
        }
        return "xmlRelationshipSpecifiers";
    }

    /**
     * Get the set of Relative Codes in XML for use by AjaxTags.
     * 
     * @return the stream containing the XML encoding the set of disease sub types
     * @throws IllegalAccessException on error
     * @throws NoSuchMethodException on error
     * @throws InvocationTargetException on error
     * @throws UnsupportedEncodingException on error
     */
    public InputStream getRelationshipSpecifiersAsXml() throws IllegalAccessException, NoSuchMethodException,
            InvocationTargetException, UnsupportedEncodingException {
        AjaxXmlBuilder xmlBuilder = new AjaxXmlBuilder();
        if (!this.relationshipSpecifiers.isEmpty()) {
            List<LabelValue> codeList = new ArrayList<LabelValue>();
            codeList.add(new LabelValue(getText("person.select.pleaseSpecify"), ""));
            for (RelativeCode currSpecifier : relationshipSpecifiers) {
                codeList.add(new LabelValue(getText(currSpecifier.getResourceKey()), currSpecifier.toString()));
            }
            xmlBuilder.addItems(codeList, "label", "value");
        }
        return new ByteArrayInputStream(xmlBuilder.toString().getBytes("UTF-8"));
    }

    /**
     * Action to load the relative selection div.
     * 
     * @return the result
     */
    public String retrieveParents() {
        parents = FhhUtils.getParents(selectedCodeValue, getPerson().getRelatives());
        return "xmlParents";
    }

    /**
     * Get the set of Relative Codes in XML for use by AjaxTags.
     * 
     * @return the stream containing the XML encoding the set of disease sub types
     * @throws IllegalAccessException on error
     * @throws NoSuchMethodException on error
     * @throws InvocationTargetException on error
     * @throws UnsupportedEncodingException on error
     */
    public InputStream getParentsAsXml() throws IllegalAccessException, NoSuchMethodException,
            InvocationTargetException, UnsupportedEncodingException {
        AjaxXmlBuilder xmlBuilder = new AjaxXmlBuilder();
        if (!this.parents.isEmpty()) {
            List<LabelValue> codeList = new ArrayList<LabelValue>();
            codeList.add(new LabelValue(getText("person.select.pleaseSpecify"), ""));
            for (Relative currRelative : parents) {
                if (currRelative.getName() != null) {
                    codeList.add(new LabelValue(getText(currRelative.getName()), currRelative.getId().toString()));
                } else {
                    codeList.add(new LabelValue(getText(RelativeCode.getByValue(currRelative.getCode())
                            .getResourceKey()), currRelative.getId().toString()));
                }
            }
            xmlBuilder.addItems(codeList, "label", "value");
        }
        return new ByteArrayInputStream(xmlBuilder.toString().getBytes("UTF-8"));
    }

    /**
     * Method adds the relative to the person object and stores any attributes that are unique to the Relative from
     * attributes stored in the action.
     * 
     * @return path String
     */
    public String submitRelative() {
        validateSubmitFields();
        if (this.getFieldErrors().size() > 0) {
            return INPUT;
        }
        storeDOB();
        relative.setCompletedForm(TRUE);
        relative.setObservations(setupClinicalObservations());
        relative.setRaces(setupRaces());
        relative.setEthnicities(setupEthnicities());
        relative.setCode(getSelectedCode());
      
        // Used in legacy import
        relative.setUnmatchedCondition(false);
        storeCauseOfDeath();
        // Add relative if adding new relative (Not editing)
        if (relativeId == null) {
            setRelativeParent();
            getPerson().getRelatives().add(relative);
        }
        // Since information has been changed, the most recent version of the xml file has
        // not been saved.
        getPerson().setXmlFileSaved(false);
        return "submit";
    }
    
    private void validateSubmitFields() {
        checkDateOfBirth();
        checkCauseOfDeath();
        validateRequiredObject("relative.gender", "relative.gender", getRelative().getGender());
    }
    
    /**
     * Checks for DOB errors and adds fields errors if necessary.
     */
    private void checkDateOfBirth() {
        if (!StringUtils.isEmpty(getDateOfBirthString()) 
                && FormatUtils.convertStringToDate(getDateOfBirthString()) == null) {
            addFieldError("dateOfBirthString", getText("dateOfBirthString") + " " + getText("errors.invalid.date"));
        }
        validateIntegerField("relativeAge", "relative.age", getRelativeAge());
    }
    /**
     * Checks for cause of death errors and adds fields errors if necessary.
     */
    private void checkCauseOfDeath() {
        if (getCauseOfDeath() != null) {
            if (causeOfDeath.isOther() && StringUtils.isBlank(otherCOD)) {
                addFieldError("otherCOD", 
                        getText("struts.validator.causeOfDeath", new String[]{getText("person.otherCOD")}));
            }
            if (isCodSubTypesExist() && getSelectedCODSubType() == null) {
                addFieldError("causeOfDeath", 
                        getText("struts.validator.causeOfDeath", new String[]{getText("causeOfDeath")}));
            }
        }
    }
    
    private boolean storeDOB() {
        // Store date of birth (priority)
        if (StringUtils.isNotBlank(getDateOfBirthString())) {
            relative.setBirthTime(getDateOfBirthString());
            relative.setEstimatedAgeRange(null);
        } else if (getRelativeAge() != null) {
            // Store birth year
            relative.setBirthTime(FormatUtils.convertAgeToYear(Integer.valueOf(getRelativeAge())));
            relative.setEstimatedAgeRange(null);
        // If estimated age was not set, clear previous birth time
        } else if (relative.getEstimatedAgeRange() == null) {
            relative.setBirthTime(null);
        } 
        return true;
    }
    
    private void storeCauseOfDeath() {
        if (codSubTypesExist) {
            relative.setCauseOfDeath(selectedCODSubType);
        } else if (causeOfDeath != null) {
            if (causeOfDeath.isOther()) {
                Disease userEnteredCauseOfDeath = DiseaseUtils.findOrCreateNewDisease(otherCOD);
                FhhHttpSessionUtil.addUserEnteredDisease(userEnteredCauseOfDeath);
                relative.setCauseOfDeath(userEnteredCauseOfDeath);
            } else {
                relative.setCauseOfDeath(causeOfDeath);
            }
        }
    }

    /**
     * Sets the parent of the relative if the selected parent index is set.
     * Sets the Parents of the root person if the relative being added is the
     * roots Mother or Father.
     */
    private void setRelativeParent() {
        // Set parent of relative when adding a relative
        if (selectedParentIndex != null) {
            Relative selectedParent = getPerson().getRelatives().get(selectedParentIndex);
            if (RelativeCode.getByValue(selectedParent.getCode()).isMale()) {
                relative.setFather(selectedParent);
            } else {
                relative.setMother(selectedParent);
            }
            // Set Mother/Father of Person if adding Mother/Father
        } else if (relative.getCode().equals(RelativeCode.NMTH.toString())) {
            getPerson().setMother(relative);
        } else if (relative.getCode().equals(RelativeCode.NFTH.toString())) {
            getPerson().setFather(relative);
        }
    }

    /**
     * Retrieves a list of sub types for the selected disease/condition.
     *
     * @return path to get disease sub types in XML form
     */
    @SkipValidation
    public String retrieveCODSubTypes() {
        if (StringUtils.isNotBlank(currentCODValue)) {
            this.codSubTypes = FhhRegistry.getPersonService().getDiseaseSubTypes(Long.parseLong(currentCODValue));
        }
        return "xmlCODSubTypes";
    }

    /**
     * Get the set of retrieved sub types in XML for use by AjaxTags.
     *
     * @return the stream containing the XML encoding the set of disease sub types
     * @throws IllegalAccessException on error
     * @throws NoSuchMethodException on error
     * @throws InvocationTargetException on error
     * @throws UnsupportedEncodingException on error
     */
    public InputStream getCODSubTypesAsXml() throws IllegalAccessException, NoSuchMethodException,
            InvocationTargetException, UnsupportedEncodingException {
        AjaxXmlBuilder xmlBuilder = new AjaxXmlBuilder();
        if (!this.codSubTypes.isEmpty()) {
            xmlBuilder.addItems(Arrays.asList(new LabelValue(getText("person.select.pleaseSpecify"), "")), "label",
                    "value");
            xmlBuilder.addItems(this.codSubTypes, "appDisplay", "id");
        }
        return new ByteArrayInputStream(xmlBuilder.toString().getBytes("UTF-8"));
    }

    /**
     * @return the relativeCodes
     */
    public List<RelativeCode> getRelativeCodes() {
        return FhhUtils.generateValidRelativeList(existingRelativeCodes);
    }

    /**
     * @return the causeOfDeath
     */
    public Disease getCauseOfDeath() {
        return causeOfDeath;
    }

    /**
     * @param causeOfDeath the causeOfDeath to set
     */
    public void setCauseOfDeath(Disease causeOfDeath) {
        this.causeOfDeath = causeOfDeath;
    }

    /**
     * @return the selectedCODSubType
     */
    public Disease getSelectedCODSubType() {
        return selectedCODSubType;
    }

    /**
     * @param selectedCODSubType the selectedCODSubType to set
     */
    public void setSelectedCODSubType(Disease selectedCODSubType) {
        this.selectedCODSubType = selectedCODSubType;
    }

    /**
     * @return the codSubTypesExist
     */
    public boolean isCodSubTypesExist() {
        return codSubTypesExist;
    }

    /**
     * @param codSubTypesExist the codSubTypesExist to set
     */
    public void setCodSubTypesExist(boolean codSubTypesExist) {
        this.codSubTypesExist = codSubTypesExist;
    }

    /**
     * @return the relationshipSpecifier
     */
    public String getRelationshipSpecifier() {
        return relationshipSpecifier;
    }

    /**
     * @param relationshipSpecifier the relationshipSpecifier to set
     */
    public void setRelationshipSpecifier(String relationshipSpecifier) {
        this.relationshipSpecifier = relationshipSpecifier;
    }

    /**
     * @return the selectedCodeValue
     */
    public String getSelectedCodeValue() {
        return selectedCodeValue;
    }

    /**
     * @param selectedCodeValue the selectedCodeValue to set
     */
    public void setSelectedCodeValue(String selectedCodeValue) {
        this.selectedCodeValue = selectedCodeValue;
    }

    /**
     * @return the currentCODValue
     */
    public String getCurrentCODValue() {
        return currentCODValue;
    }

    /**
     * @param currentCODValue the currentCODValue to set
     */
    public void setCurrentCODValue(String currentCODValue) {
        this.currentCODValue = currentCODValue;
    }

    /**
     * @return the codSubTypes
     */
    public List<Disease> getCodSubTypes() {
        return codSubTypes;
    }

    /**
     * @param codSubTypes the codSubTypes to set
     */
    public void setCodSubTypes(List<Disease> codSubTypes) {
        this.codSubTypes = codSubTypes;
    }

    /**
     * @return the relative
     */
    public Relative getRelative() {
        return relative;
    }

    /**
     * @param relative the relative to set
     */
    public void setRelative(Relative relative) {
        this.relative = relative;
    }

    /**
     * @return the relativeId
     */
    public String getRelativeId() {
        return relativeId;
    }

    /**
     * @param relativeId the relativeId to set
     */
    public void setRelativeId(String relativeId) {
        this.relativeId = relativeId;
    }

    /**
     * @return the relationshipSpecifiers
     */
    public List<RelativeCode> getRelationshipSpecifiers() {
        return relationshipSpecifiers;
    }

    /**
     * @param relationshipSpecifiers the relationshipSpecifiers to set
     */
    public void setRelationshipSpecifiers(List<RelativeCode> relationshipSpecifiers) {
        this.relationshipSpecifiers = relationshipSpecifiers;
    }

    /**
     * @return the existingRelativeCodes
     */
    public List<String> getExistingRelativeCodes() {
        return existingRelativeCodes;
    }

    /**
     * @param existingRelativeCodes the existingRelativeCodes to set
     */
    public void setExistingRelativeCodes(List<String> existingRelativeCodes) {
        this.existingRelativeCodes = existingRelativeCodes;
    }

    /**
     * @return the parents
     */
    public List<Relative> getParents() {
        return parents;
    }

    /**
     * @param parents the parents to set
     */
    public void setParents(List<Relative> parents) {
        this.parents = parents;
    }

    /**
     * @return the selectedParentIndex
     */
    public Integer getSelectedParentIndex() {
        return selectedParentIndex;
    }

    /**
     * @param selectedParentIndex the selectedParentIndex to set
     */
    public void setSelectedParentIndex(Integer selectedParentIndex) {
        this.selectedParentIndex = selectedParentIndex;
    }

    /**
     * @return the otherCOD
     */
    public String getOtherCOD() {
        return otherCOD;
    }

    /**
     * @param otherCOD the otherCOD to set
     */
    public void setOtherCOD(String otherCOD) {
        this.otherCOD = otherCOD;
    }

    /**
     * @return the lastAddedCOD
     */
    public String getLastAddedCOD() {
        return lastAddedCOD;
    }

    /**
     * @param lastAddedCOD the lastAddedCOD to set
     */
    public void setLastAddedCOD(String lastAddedCOD) {
        this.lastAddedCOD = lastAddedCOD;
    }

    /**
     * @return the relativeAge
     */
    public String getRelativeAge() {
        return relativeAge;
    }

    /**
     * @param relativeAge the relativeAge to set
     */
    public void setRelativeAge(String relativeAge) {
        this.relativeAge = relativeAge;
    }
}
