/**
 *
 * Family Health History Portal
 * END USER AGREEMENT
 *
 * The U.S. Department of Health & Human Services ("HHS") hereby irrevocably
 * grants to the user a non-exclusive, royalty-free right to use, display,
 * reproduce, and distribute this Family Health History portal software
 * (the "software") and prepare, use, display, reproduce and distribute
 * derivative works thereof for any commercial or non-commercial purpose by any
 * party, subject only to the following limitations and disclaimers, which
 * are hereby acknowledged by the user.
 *
 * User agrees that it will not degrade the standards-based format of the software
 * by materially altering the program architecture or data structure in a way
 * that would render the data generated by the altered software incompatible
 * with the original software. The intention of this clause is to ensure the
 * long-term interoperability of family history information gathered by different
 * versions of the tool.
 *
 * User agrees that this END USER AGREEMENT will be provided to any party to
 * whom user distributes the software, and that it will apply to the distributee.
 *
 * User agrees that it will not use the HHS or Surgeon General logo or any HHS
 * trademarks without permission from HHS, and will not imply endorsement of
 * its product by HHS or the Surgeon General.
 *
 * THIS SOFTWARE IS PROVIDED TO USER WITH NO WARRANTIES, EXPRESS OR IMPLIED,
 * INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE,
 * OR THAT THE USE OF THE SOFWARE WILL NOT INFRINGE ANY PATENT, COPYRIGHT,
 * TRADEMARK OR OTHER PROPRIETARY RIGHTS.
 *
 */
package gov.hhs.fhh.web.action;

import gov.hhs.fhh.data.Disease;
import gov.hhs.fhh.data.Person;
import gov.hhs.fhh.data.Relative;
import gov.hhs.fhh.data.RelativeCode;
import gov.hhs.fhh.data.UserEnteredDisease;
import gov.hhs.fhh.data.util.DiseaseUtils;
import gov.hhs.fhh.data.util.FormatUtils;
import gov.hhs.fhh.data.util.LabelValue;
import gov.hhs.fhh.data.util.PersonUtils;
import gov.hhs.fhh.service.locator.FhhRegistry;
import gov.hhs.fhh.service.util.FhhUtils;
import gov.hhs.fhh.web.util.FhhHttpSessionUtil;
import gov.hhs.fhh.web.util.RelativeToRelateTo;
import gov.hhs.mfhp.model.Observation;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.UUID;

import org.ajaxtags.xml.AjaxXmlBuilder;
import org.apache.commons.lang.StringUtils;
import org.apache.struts2.interceptor.validation.SkipValidation;

import com.fiveamsolutions.hl7.model.mfhp.Gender;
import com.opensymphony.xwork2.Preparable;
import com.opensymphony.xwork2.validator.annotations.RequiredFieldValidator;
import com.opensymphony.xwork2.validator.annotations.Validations;

/**
 * @author bpickeral
 *
 */
@SuppressWarnings({ "PMD.CyclomaticComplexity", "PMD.ExcessiveClassLength",
    "PMD.TooManyFields", "PMD.TooManyMethods" })
public class AddRelativeAction extends AddPersonAction implements Preparable {
    private static final long serialVersionUID = 1927846653L;
    private static final boolean TRUE = true;
    private static final String REQUIRED_FIELD = "struts.validator.requiredString";

    private Relative relative;

    private List<Disease> codSubTypes = new ArrayList<Disease>();
    private List<RelativeCode> relationshipSpecifiers = new ArrayList<RelativeCode>();
    private List<String> existingRelativeCodes = new ArrayList<String>();
    private List<Relative> parents = new ArrayList<Relative>();
    private Disease causeOfDeath;
    private Disease selectedCODSubType;
    private String relativeAge;
    private boolean codSubTypesExist;
    private String relationshipSpecifier;
    private String selectedCodeValue;
    private String currentCODValue;
    private boolean needsRelating;
    private String relativeToSetAsParentUuid;
    private boolean relativeToSetAsParentHalfSiblingStatus;

    /**
     * The UUID of the selected parent.
     */
    private String selectedParentIndex;
    private String relativeId;
    private String otherCOD;
    private String lastAddedCOD;

    /**
     * {@inheritDoc}
     */
    @Override
    public void prepare() {
        Person rootPerson = FhhHttpSessionUtil.getRootPerson();

        if (rootPerson != null) {
            setPerson(rootPerson);
            if (getRelativeId() != null) {
                setRelative(getPerson().getRelative(UUID.fromString(getRelativeId())));
                setSelectedCode(getRelative().getCode());
                setupDiseasesAndAges(getRelative());
                setupBirthYear();
                setupCauseOfDeath();
                setupLegacyWarningMessages(getRelative());
                if (getPerson().getUnrelatedRelatives().contains(getRelative())) {
                    setNeedsRelating(true);
                }
            } else {
                setRelative(new Relative());
            }
            setupGender();
            setSelectionVariables();
        }
    }

    /**
     * Sets the Birth year or Date of birth to be displayed in the jsp for a Relative that is being edited.
     */
    public void setupBirthYear() {
        if (getRelative().getBirthTime() != null) {
            if (FormatUtils.checkDateFormat(getRelative().getBirthTime())) {
                setDateOfBirthString(getRelative().getBirthTime());
            } else {
                Calendar calendar = Calendar.getInstance();
                Integer birthYear = Integer.valueOf(getRelative().getBirthTime());
                setRelativeAge(String.valueOf(calendar.get(Calendar.YEAR) - birthYear));
            }
        }
    }

    /**
     * Sets the Cause of death to be displayed in the jsp for a Relative that is being edited.
     */
    public void setupCauseOfDeath() {
        setCauseOfDeath(null);
        // The COD is added to the Disease List, store the ID of the row in the Disease List table of the last
        // added COD. This is used to remove the COD when a new COD is entered.
        setCodSubTypesExist(false);
        if (getRelative().getCauseOfDeath() != null) {
            if (getRelative().getCauseOfDeath().getParent() == null) {
                setCauseOfDeath(getRelative().getCauseOfDeath());
                if (getRelative().getCauseOfDeath().isOther()
                        && (getRelative().getCauseOfDeath() instanceof UserEnteredDisease)) {
                    setOtherCOD(getRelative().getCauseOfDeath().getOriginalText());
                }

                setLastAddedCOD(DiseaseUtils.generateDiseaaseTableId(getRelative().getCauseOfDeath(), getRelative()
                        .getAgeAtDeath()));
            } else {
                setCauseOfDeath(getRelative().getCauseOfDeath().getParent());
                setSelectedCODSubType(getRelative().getCauseOfDeath());
                setCodSubTypesExist(TRUE);
                setLastAddedCOD(DiseaseUtils.generateDiseaaseTableId(getSelectedCODSubType(), getRelative()
                        .getAgeAtDeath()));
            }
        }
    }

    /**
     * Set the implied gender of the Relative when adding a new relative.
     */
    private void setupGender() {
        if (!StringUtils.isEmpty(getSelectedCode()) && getRelative().getGender() == null
                && RelativeCode.getByValue(getSelectedCode()).getImpliedGender() != null) {
            getRelative().setGender(RelativeCode.getByValue(getSelectedCode()).getImpliedGender());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setSelectionVariables() {
        // Set up variables for Edit/Add Relative
        if (getSelectedCode() != null) {
            if (getCauseOfDeath() != null) {
                setCodSubTypes(FhhRegistry.getPersonService().getDiseaseSubTypes(getCauseOfDeath().getId()));
            }
            super.setSelectionVariables();
            // Set up variables for select relative
        } else {
            setExistingRelativeCodes(FhhUtils.getExistingCodes(getPerson().getRelatives()));
        }

    }

    /**
     * Validates selected relative and then sends the user to addPerson.
     * @return response
     */
    @Validations(requiredFields = { @RequiredFieldValidator(fieldName = "selectedCode",
            key = REQUIRED_FIELD, message = "") })
    public String confirmSelectedRelative() {
        addPerson();
        return "addPerson";
    }

    /**
     * Method is called after selecting a relative to call the add person page.
     *
     * @return path String
     */
    @Override
    public String addPerson() {
        // Other Disease Values should be reset when a new person is added
        setOtherDiseaseValues(new ArrayList<String>());
        RelativeCode code = RelativeCode.getByValue(getSelectedCode());
        // Check for errors, return if errors are present
        checkSelectRelativeErrors(code);
        if (!getFieldErrors().isEmpty()) {
            return INPUT;
        }
        // Handle Maternal/Paternal codes
        if (code.isSpecifier()) {
            // Cousin specifies parent - set Maternal/Paternal
            if (RelativeCode.COUSN.toString().equals(code.toString())) {
                Relative parent = getPerson().getRelative(UUID.fromString(getSelectedParentIndex()));
                if (RelativeCode.MAUNT.toString().equals(parent.getCode())
                        || RelativeCode.MUNCLE.toString().equals(parent.getCode())) {
                    setSelectedCode(code.getMaternalCode());
                } else {
                    setSelectedCode(code.getPaternalCode());
                }
                // All other codes specify Maternal/Paternal
            } else if (RelativeCode.NMTH.toString().equals(getRelationshipSpecifier())) {
                setSelectedCode(code.getMaternalCode());
            } else {
                setSelectedCode(code.getPaternalCode());
            }
        }

        return SUCCESS;
    }

    /**
     * Method adds field errors for the addPerson Method called when selecting a relative to add to the family tree.
     *
     * @param code of the relative being added
     */
    private void checkSelectRelativeErrors(RelativeCode code) {
        // Add errors if Parent was not specified for codes that require specification.
        if (!FhhUtils.getParents(code.toString(), getPerson().getRelatives()).isEmpty()
                && getSelectedParentIndex() == null) {
            addFieldError("selectedParentIndex", getText("selectedParentIndex") + " " + getText(REQUIRED_FIELD));
        }
        // Add error if no Maternal/Paternal relationship was specified
        if (code.isSpecifier() && !RelativeCode.COUSN.toString().equals(code.toString())
                && getRelationshipSpecifier() == null) {
            addFieldError("relationshipSpecifier", getText("relationshipSpecifier") + " " + getText(REQUIRED_FIELD));
        }
    }

    /**
     * Action to load the relative selection div.
     *
     * @return the result
     */
    public String retrieveRelationshipSpecifiers() {
        if (RelativeCode.getByValue(getSelectedCodeValue()).isSpecifier()) {
            setRelationshipSpecifiers(FhhUtils.getRelationshipSpecifiers(selectedCodeValue));
        }
        return "xmlRelationshipSpecifiers";
    }

    /**
     * Get the set of Relative Codes in XML for use by AjaxTags.
     *
     * @return the stream containing the XML encoding the set of disease sub types
     * @throws IllegalAccessException on error
     * @throws NoSuchMethodException on error
     * @throws InvocationTargetException on error
     * @throws UnsupportedEncodingException on error
     */
    public InputStream getRelationshipSpecifiersAsXml() throws IllegalAccessException, NoSuchMethodException,
            InvocationTargetException, UnsupportedEncodingException {
        AjaxXmlBuilder xmlBuilder = new AjaxXmlBuilder();
        if (!getRelationshipSpecifiers().isEmpty()) {
            List<LabelValue> codeList = new ArrayList<LabelValue>();
            codeList.add(new LabelValue(getText("person.select.pleaseSpecify"), ""));
            for (RelativeCode currSpecifier : getRelationshipSpecifiers()) {
                codeList.add(new LabelValue(getText(currSpecifier.getResourceKey()), currSpecifier.toString()));
            }
            xmlBuilder.addItems(codeList, "label", "value");
        }
        return new ByteArrayInputStream(xmlBuilder.toString().getBytes("UTF-8"));
    }

    /**
     * Action to load the relative selection div.
     *
     * @return the result
     */
    public String retrieveParents() {
        setParents(FhhUtils.getParents(selectedCodeValue, getPerson().getRelatives()));
        return "xmlParents";
    }

    /**
     * Get the set of Relative Codes in XML for use by AjaxTags.
     *
     * @return the stream containing the XML encoding the set of disease sub types
     * @throws IllegalAccessException on error
     * @throws NoSuchMethodException on error
     * @throws InvocationTargetException on error
     * @throws UnsupportedEncodingException on error
     */
    public InputStream getParentsAsXml() throws IllegalAccessException, NoSuchMethodException,
            InvocationTargetException, UnsupportedEncodingException {
        AjaxXmlBuilder xmlBuilder = new AjaxXmlBuilder();
        if (!getParents().isEmpty()) {
            List<LabelValue> codeList = new ArrayList<LabelValue>();
            codeList.add(new LabelValue(getText("person.select.pleaseSpecify"), ""));
            for (Relative currRelative : getParents()) {
                if (currRelative.getName() != null) {
                    codeList.add(new LabelValue(getText(currRelative.getName()), currRelative.getUuid().toString()));
                } else {
                    codeList.add(new LabelValue(getText(RelativeCode.getByValue(currRelative.getCode())
                            .getResourceKey()), currRelative.getUuid().toString()));
                }
            }
            xmlBuilder.addItems(codeList, "label", "value");
        }
        return new ByteArrayInputStream(xmlBuilder.toString().getBytes("UTF-8"));
    }

    /**
     * Method adds the relative to the person object and stores any attributes that are unique to the Relative from
     * attributes stored in the action.
     *
     * @return path String
     */
    public String submitRelative() {
        validateSubmitFields();
        if (this.getFieldErrors().size() > 0) {
            return INPUT;
        }
        storeDOB();
        getRelative().setObservations(setupClinicalObservations());
        getRelative().setRaces(setupRaces());
        getRelative().setEthnicities(setupEthnicities());
        if (getRelativeToSetAsParentUuid() != null) {
            handleRelatingToRelative();
        } else {
            getRelative().setCode(getSelectedCode());
        }

        // Used in legacy import
        getRelative().setUnmatchedCondition(false);
        storeCauseOfDeath();
        // Add relative if adding new relative (Not editing)
        if (getRelativeId() == null) {
            setRelativeParent();
            getPerson().getRelatives().add(getRelative());
        }
        // Since information has been changed, the most recent version of the xml file has
        // not been saved.
        getPerson().setXmlFileSaved(false);
        return "submit";
    }

    private void handleRelatingToRelative() {
        UUID parentUuid = UUID.fromString(getRelativeToSetAsParentUuid());
        if (isParentRelativeProband(parentUuid)) {
            getPerson().getDescendants().add(getRelative());
            getRelative().setCodeEnum(
                    RelativeCode.SELF.getRelativeCodeForParentCode(getRelative().getGender(),
                            isRelativeToSetAsParentHalfSiblingStatus()));
        } else {
            Relative parent = getPerson().getRelative(parentUuid);
            Gender parentGender = parent.getGender();
            if (parentGender == null) {
                parentGender = parent.getCodeEnum().getImpliedGender();
            }
            if (Gender.MALE.equals(parentGender)) {
                getRelative().setFather(parent);
            } else if (Gender.FEMALE.equals(parentGender)) {
                getRelative().setMother(parent);
            }
            getRelative().setCodeEnum(
                    parent.getCodeEnum().getRelativeCodeForParentCode(getRelative().getGender(),
                            isRelativeToSetAsParentHalfSiblingStatus()));
        }
        getPerson().getUnrelatedRelatives().remove(getRelative());
        getPerson().getRelatives().add(getRelative());
    }

    private boolean isParentRelativeProband(UUID parentUuid) {
        return getPerson().getUuid().equals(parentUuid);
    }

    private void validateSubmitFields() {
        checkDateOfBirth();
        checkCauseOfDeath();
        validateRequiredObject("relative.gender", "relative.gender", getRelative().getGender());
    }

    /**
     * Checks for DOB errors and adds fields errors if necessary.
     */
    private void checkDateOfBirth() {
        if (!StringUtils.isEmpty(getDateOfBirthString())
                && FormatUtils.convertStringToDate(getDateOfBirthString()) == null) {
            addFieldError("dateOfBirthString", getText("dateOfBirthString") + " " + getText("errors.invalid.date"));
        }
        validateIntegerField("relativeAge", "relative.age", getRelativeAge());
    }

    /**
     * Checks for cause of death errors and adds fields errors if necessary.
     */
    private void checkCauseOfDeath() {
        if (getCauseOfDeath() != null) {
            if (getCauseOfDeath().isOther() && StringUtils.isBlank(getOtherCOD())) {
                addFieldError("otherCOD", getText("struts.validator.causeOfDeath",
                        new String[] {getText("person.otherCOD") }));
            }
            if (isCodSubTypesExist() && getSelectedCODSubType() == null) {
                addFieldError("causeOfDeath", getText("struts.validator.causeOfDeath",
                        new String[] {getText("causeOfDeath") }));
            }
        }
    }

    private boolean storeDOB() {
        // Store date of birth (priority)
        if (StringUtils.isNotBlank(getDateOfBirthString())) {
            getRelative().setBirthTime(getDateOfBirthString());
            getRelative().setEstimatedAgeRange(null);
        } else if (getRelativeAge() != null) {
            // Store birth year
            getRelative().setBirthTime(FormatUtils.convertAgeToYear(Integer.valueOf(getRelativeAge())));
            getRelative().setEstimatedAgeRange(null);
            // If estimated age was not set, clear previous birth time
        } else if (getRelative().getEstimatedAgeRange() == null) {
            getRelative().setBirthTime(null);
        }
        return true;
    }

    private void storeCauseOfDeath() {

        if (isCodSubTypesExist()) {
            getRelative().setCauseOfDeath(getSelectedCODSubType());
        } else if (getCauseOfDeath() != null) {
            if (getCauseOfDeath() instanceof Observation
                    && FhhRegistry.getPersonService().isOtherPseudoType((Observation) getCauseOfDeath())) {
                Disease userEnteredCauseOfDeath = DiseaseUtils.findOrCreateNewDisease(getOtherCOD());
                FhhHttpSessionUtil.addUserEnteredDisease(userEnteredCauseOfDeath);
                getRelative().setCauseOfDeath(userEnteredCauseOfDeath);
            } else {
                getRelative().setCauseOfDeath(getCauseOfDeath());
            }
        } else {
            getRelative().setCauseOfDeath(null);

        }
    }

    /**
     * Sets the parent of the relative if the selected parent index is set. Sets the Parents of the root person if the
     * relative being added is the roots Mother or Father.
     */
    private void setRelativeParent() {
        // Set parent of relative when adding a relative
        if (getSelectedParentIndex() != null) {
            Relative selectedParent = getPerson().getRelative(UUID.fromString(getSelectedParentIndex()));
            if (RelativeCode.getByValue(selectedParent.getCode()).isMale()) {
                getRelative().setFather(selectedParent);
            } else {
                getRelative().setMother(selectedParent);
            }
        } else {
            PersonUtils.setKnownParents(getPerson(), getRelative());
        }
    }

    /**
     * Retrieves a list of sub types for the selected disease/condition.
     *
     * @return path to get disease sub types in XML form
     */
    @SkipValidation
    public String retrieveCODSubTypes() {
        if (StringUtils.isNotBlank(getCurrentCODValue())) {
            setCodSubTypes(FhhRegistry.getPersonService().getDiseaseSubTypes(Long.parseLong(getCurrentCODValue())));
        }
        return "xmlCODSubTypes";
    }

    /**
     * Get the set of retrieved sub types in XML for use by AjaxTags.
     *
     * @return the stream containing the XML encoding the set of disease sub types
     * @throws IllegalAccessException on error
     * @throws NoSuchMethodException on error
     * @throws InvocationTargetException on error
     * @throws UnsupportedEncodingException on error
     */
    public InputStream getCODSubTypesAsXml() throws IllegalAccessException, NoSuchMethodException,
            InvocationTargetException, UnsupportedEncodingException {
        AjaxXmlBuilder xmlBuilder = new AjaxXmlBuilder();
        if (!getCodSubTypes().isEmpty()) {
            xmlBuilder.addItems(Arrays.asList(new LabelValue(getText("person.select.pleaseSpecify"), "")), "label",
                    "value");
            xmlBuilder.addItems(getCodSubTypes(), "appDisplay", "id");
        }
        return new ByteArrayInputStream(xmlBuilder.toString().getBytes("UTF-8"));
    }

    /**
     * @return the relativeCodes
     */
    public List<RelativeCode> getRelativeCodes() {
        return FhhUtils.generateValidRelativeList(existingRelativeCodes);
    }

    /**
     * @return the causeOfDeath
     */
    public Disease getCauseOfDeath() {
        return causeOfDeath;
    }

    /**
     * @param causeOfDeath the causeOfDeath to set
     */
    public void setCauseOfDeath(Disease causeOfDeath) {
        this.causeOfDeath = causeOfDeath;
    }

    /**
     * @return the selectedCODSubType
     */
    public Disease getSelectedCODSubType() {
        return selectedCODSubType;
    }

    /**
     * @param selectedCODSubType the selectedCODSubType to set
     */
    public void setSelectedCODSubType(Disease selectedCODSubType) {
        this.selectedCODSubType = selectedCODSubType;
    }

    /**
     * @return the codSubTypesExist
     */
    public boolean isCodSubTypesExist() {
        return codSubTypesExist;
    }

    /**
     * @param codSubTypesExist the codSubTypesExist to set
     */
    public void setCodSubTypesExist(boolean codSubTypesExist) {
        this.codSubTypesExist = codSubTypesExist;
    }

    /**
     * @return the relationshipSpecifier
     */
    public String getRelationshipSpecifier() {
        return relationshipSpecifier;
    }

    /**
     * @param relationshipSpecifier the relationshipSpecifier to set
     */
    public void setRelationshipSpecifier(String relationshipSpecifier) {
        this.relationshipSpecifier = relationshipSpecifier;
    }

    /**
     * @return the selectedCodeValue
     */
    public String getSelectedCodeValue() {
        return selectedCodeValue;
    }

    /**
     * @param selectedCodeValue the selectedCodeValue to set
     */
    public void setSelectedCodeValue(String selectedCodeValue) {
        this.selectedCodeValue = selectedCodeValue;
    }

    /**
     * @return the currentCODValue
     */
    public String getCurrentCODValue() {
        return currentCODValue;
    }

    /**
     * @param currentCODValue the currentCODValue to set
     */
    public void setCurrentCODValue(String currentCODValue) {
        this.currentCODValue = currentCODValue;
    }

    /**
     * @return the codSubTypes
     */
    public List<Disease> getCodSubTypes() {
        return codSubTypes;
    }

    /**
     * @param codSubTypes the codSubTypes to set
     */
    public void setCodSubTypes(List<Disease> codSubTypes) {
        this.codSubTypes = codSubTypes;
    }

    /**
     * @return the relative
     */
    public Relative getRelative() {
        return relative;
    }

    /**
     * @param relative the relative to set
     */
    public void setRelative(Relative relative) {
        this.relative = relative;
    }

    /**
     * @return the relativeId
     */
    public String getRelativeId() {
        return relativeId;
    }

    /**
     * @param relativeId the relativeId to set
     */
    public void setRelativeId(String relativeId) {
        this.relativeId = relativeId;
    }

    /**
     * @return the relationshipSpecifiers
     */
    public List<RelativeCode> getRelationshipSpecifiers() {
        return relationshipSpecifiers;
    }

    /**
     * @param relationshipSpecifiers the relationshipSpecifiers to set
     */
    public void setRelationshipSpecifiers(List<RelativeCode> relationshipSpecifiers) {
        this.relationshipSpecifiers = relationshipSpecifiers;
    }

    /**
     * @return the existingRelativeCodes
     */
    public List<String> getExistingRelativeCodes() {
        return existingRelativeCodes;
    }

    /**
     * @param existingRelativeCodes the existingRelativeCodes to set
     */
    public void setExistingRelativeCodes(List<String> existingRelativeCodes) {
        this.existingRelativeCodes = existingRelativeCodes;
    }

    /**
     * @return the parents
     */
    public List<Relative> getParents() {
        return parents;
    }

    /**
     * @param parents the parents to set
     */
    public void setParents(List<Relative> parents) {
        this.parents = parents;
    }

    /**
     * Is really the Person.uuid as a String.
     *
     * @return the selectedParentIndex
     */
    public String getSelectedParentIndex() {
        return selectedParentIndex;
    }

    /**
     * @param selectedParentIndex the selectedParentIndex to set
     */
    public void setSelectedParentIndex(String selectedParentIndex) {
        this.selectedParentIndex = selectedParentIndex;
    }

    /**
     * @return the otherCOD
     */
    public String getOtherCOD() {
        return otherCOD;
    }

    /**
     * @param otherCOD the otherCOD to set
     */
    public void setOtherCOD(String otherCOD) {
        this.otherCOD = otherCOD;
    }

    /**
     * @return the lastAddedCOD
     */
    public String getLastAddedCOD() {
        return lastAddedCOD;
    }

    /**
     * @param lastAddedCOD the lastAddedCOD to set
     */
    public void setLastAddedCOD(String lastAddedCOD) {
        this.lastAddedCOD = lastAddedCOD;
    }

    /**
     * @return the relativeAge
     */
    public String getRelativeAge() {
        return relativeAge;
    }

    /**
     * @param relativeAge the relativeAge to set
     */
    public void setRelativeAge(String relativeAge) {
        this.relativeAge = relativeAge;
    }

    /**
     * @return - the list of parents it is possible to relate this unrelatedRelative to.
     */
    public List<RelativeToRelateTo> getRelativesToRelateTo() {
        List<RelativeToRelateTo> retval = null;

        if (getRelative().getCodeEnum() != null && getRelative().getCodeEnum().getPossibleParents() != null
                && !getRelative().getCodeEnum().getPossibleParents().isEmpty()) {
            retval = getRelativesToRelateTo(getPerson().getRelatives(), getRelative().getCodeEnum()
                    .getPossibleParents());
        } else {
            retval = getRelativesToRelateTo(getPerson().getRelatives(), RelativeCode.getCodesThatCanBeParents());
            retval.add(new RelativeToRelateTo(getPerson(), getText(RelativeCode.SELF.getResourceKey())));
        }

        return retval;
    }

    private List<RelativeToRelateTo> getRelativesToRelateTo(List<Relative> relativesToPickFrom,
            List<RelativeCode> relativeCodesToAllowAsParents) {
        List<RelativeToRelateTo> retval = new ArrayList<RelativeToRelateTo>();
        for (Relative currRelative : relativesToPickFrom) {
            RelativeCode currCode = currRelative.getCodeEnum();
            if (relativeCodesToAllowAsParents.contains(currCode)) {
                retval.add(new RelativeToRelateTo(currRelative, getText(currRelative.getCodeEnum().getResourceKey())));
            }
        }
        return retval;
    }

    /**
     * @return the relativeToSetAsParentUuid
     */
    public String getRelativeToSetAsParentUuid() {
        return relativeToSetAsParentUuid;
    }

    /**
     * @param relativeToSetAsParentUuid the relativeToSetAsParentUuid to set
     */
    public void setRelativeToSetAsParentUuid(String relativeToSetAsParentUuid) {
        this.relativeToSetAsParentUuid = relativeToSetAsParentUuid;
    }

    /**
     * @return the relativeToSetAsParentHalfSiblingStatus
     */
    public boolean isRelativeToSetAsParentHalfSiblingStatus() {
        return relativeToSetAsParentHalfSiblingStatus;
    }

    /**
     * @param relativeToSetAsParentHalfSiblingStatus the relativeToSetAsParentHalfSiblingStatus to set
     */
    public void setRelativeToSetAsParentHalfSiblingStatus(boolean relativeToSetAsParentHalfSiblingStatus) {
        this.relativeToSetAsParentHalfSiblingStatus = relativeToSetAsParentHalfSiblingStatus;
    }

    /**
     * @return the needsRelating
     */
    public boolean isNeedsRelating() {
        return needsRelating;
    }

    /**
     * @param needsRelating the needsRelating to set
     */
    public void setNeedsRelating(boolean needsRelating) {
        this.needsRelating = needsRelating;
    }
}
